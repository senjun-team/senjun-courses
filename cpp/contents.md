**Содержание курса по C++**

Это попытка организовать обучение по спирали. Одни и те же темы будут всплывать неоднократно по мере углубления понимания C++. При этом в главах будут расставлены кросс-ссылки, чтобы было удобнее использовать курс как справочник и для подготовки к собесам.

# Глава 0. О курсе [DONE]
- Цель курса
- Наш подход к обучению
- Для кого этот курс
- Для кого этот курс не подходит
- Как проходить курс
- Ответы на частые вопросы
    - Нужно ли начинать изучение C++ с Си?
    - Нужно ли для изучения C++ знать ассемблер?
    - Что делать, если не получается решить задачу или выполнить проект?
    - Куда сообщать об ошибках?

# Глава 1. Что такое C++ [DONE]
- Философия С++
    - Свобода выбора
    - Обратная совместимость
    - Эффективность
- Что делает язык C++ языком C++
    - Слабая статическая типизация
    - ООП
    - Метапрограммирование
- Развитие языка
- Экосистема вокруг языка
    - Сборка
    - IDE и редакторы
    - Библиотеки и фреймворки
    - Линтеры, форматтеры и статические анализаторы кода
- Мифы о C++
    - Мифический язык C/C++
    - C++ небезопасен
- Области применения C++

# Глава 2. Базовый синтаксис [DONE]
- Правила именования
- Правила форматирования
- Точка входа в программу
- Функции
- Переменные
- Константы
- Знакомство с фундаментальными типами
    - Типы int и double
    - Тип bool
    - Тип char
    - Тип void
- Знакомство с библиотечными типами
    - Тип std::size_t
    - Класс std::string
- Операторы
    - Операторы сравнения
    - Логические операторы
    - Арифметические операторы
    - Составное присваивание
    - Инкремент и декремент
    - Приоритет операторов

# Глава 3. Управляющие конструкции [DONE]
- Условное выполнение кода
    - Условия if-else
    - Тернарный оператор
    - Конструкция switch-case
- Циклы
    - Цикл while
    - Цикл do-while
    - Цикл for

# ПРОЕКТ. Деление без деления [DONE]
- Алгоритм целочисленного деления без использования операций деления, умножения и получения остатка

# Глава 5. Экскурсия по C++ [DONE]
- Перегрузка функций
- Исключения
- Пространства имен
- Перечисления enum
- Перечисления enum class
- Классы
    - Конструкторы и деструкторы
    - Идиома RAII
- Структуры
- Шаблоны

# Глава 6. Итераторы [DONE]
- Что такое итератор
- Реализация итераторов в C++
- Основные действия над итераторами
- Константные итераторы
- Обратные итераторы
- Ключевое слово auto
- Инвалидация итераторов
- Строка — это контейнер?

# Глава 7. Контейнеры [DONE]
- Глава 7.1. Какие бывают контейнеры
    - Классификация контейнеров
- Глава 7.2. Последовательные контейнеры
    - Класс vector
    - Класс array
    - Класс deque
    - Классы list и forward_list
    - Резюме (алгоритмическая сложность)
- Глава 7.3. Упорядоченные ассоциативные контейнеры
    - Класс pair
    - Класс map
    - Класс set
    - Классы multimap и multiset
    - Резюме (алгоритмическая сложность)
- Глава 7.4. Неупорядоченные ассоциативные контейнеры
    - Класс unordered_set
    - Класс unordered_map
    - Классы unordered_multimap и unordered_multiset
    - Резюме (алгоритмическая сложность)
- Глава 7.5. Адаптеры
    - Класс queue
    - Класс stack
    - flat-версии ассоциативных контейнеров
    - Резюме (алгоритмическая сложность)

# ПРОЕКТ. Скользящее среднее [DONE]
- Класс для расчета скользящего среднего в заданном окне

# Глава 8. Обзор алгоритмов [DONE]
- Глава 8.1. Немодифицирующие алгоритмы
    - Мотивация применять алгоритмы
    - Обзор алгоритмов стандартной библиотеки
    - Поиск
    - Бинарный поиск
    - Подсчет
- Глава 8.2. Модифицирующие алгоритмы
    - Сортировка
        - Как реализована сортировка
        - Компараторы
        - Требования к компараторам
    - Копирование
        - Итераторы-адаптеры
    - Удаление
        - Идиома erase-remove
    - Когда использовать алгоритмы, а когда — методы класса?
    - Оптимальны ли алгоритмы и контейнеры

# Глава 9. Время жизни и область видимости [DONE]
- Где живут переменные
- Время жизни
- Локальные переменные
- Глобальные переменные
- Статические переменные
- Затенение имен
- Вложенные блоки кода и RAII
- Инициализаторы в if и switch

# ПРОЕКТ. Интерпретатор Brainfuck [DONE]
- Класс для выполнения кода на брейнфаке

# Глава 10. Структура программы [DONE]
- Объявления и определения
- Проекты до появления модулей
    - Структура проекта с хедерами и cpp-файлами
    - Директивы препроцессора
    - Подключение хедеров
    - Недостатки использования хедеров
- Проекты с модулями
    - Преимущества модулей
    - Импорт модулей
    - Структура простого модуля
    - Подключение хедеров внутри модуля
    - Сквозной импорт модулей
    - Структура проекта с модулями
    - Как соотносятся модули и пространства имен

# Глава 11. Сборка программы [DONE]
- Компиляция
- Компиляторы C++
- Пайплайн компиляции
- Препроцессинг
- Компиляция
- Ассемблирование
- Линковка
    - Видимость символа для линкера
    - Статическая и динамическая линковка
- C++ ABI
- Библиотеки
- Рантайм C++
- Сборка проекта с модулями
    - Модуль стандартной библиотеки
    - Пользовательские модули
- Автоматизация сборки

# Глава 12. Автоматизция сборки программы [DONE]
- Что такое CMake
- Команды CMake
- Процесс сборки через CMake
    - Сборка простого проекта с хедерами
    - Сборка простого проекта с модулями
- Подпроекты
- Типы сборок
- Варианты установки переменных
- Вывод информации в консоль
- Работа с зависимостями
    - Подключение библиотек, которые установлены в системе
    - Подключение библиотек через модуль CMake
- Что использовать вместо CMake
- Пакетные менеджеры

# ПРОЕКТ. LRU кеш  [DONE]
- Класс, реализующий стратегию кэширования least recently used

# Глава 13. Щадящее введение в инициализацию [DONE]
- Глава 13.1. Основные способы инициализации
    - Default-initialization: инициализация по умолчанию
    - Copy-initialization: копирующая инициализация
        - Неявное приведение типов
        - Запрет неявного преобразования аргументов конструктора
    - Direct-initialization: прямая инициализация
        - The most vexing parse
    - Uniform-initialization: универсальная инициализация
- Глава 13.2. Инициализация полей классов
    - Default member initialization: прямая инициализация полей
    - Member initializer list: список инициализации конструктора
    - Designated-initialization: назначенная инициализация

# Типы данных [IN PROGRESS]
- Классификация типов - что такое POD, фундаментальный тип, скалярный тип и тд
- Встроенные типы и что с ними можно делать
- Модификаторы типов signed, unsigned, long и short
- Приведение типов
- Подводка к ссылкам и указателям

# Ссылки
- Мотивация
- Синтаксис
- Продление жизни временных объектов

# Функции
- Способы передачи аргументов
- Значения аргументов по умолчанию
- Порядок вычисления аргументов функции
- Перегрузка функций
- inline

# Строки, форматирование и ввод/вывод
- std::string
- std::wstring
- Концепция стримов
- std::format
- std::print
- Файлы

# ПРОЕКТ. Утилита tree
- Консольная утилита для отображения иерархии директорий в виде дерева

# Алиасы
- typedef
- using

# Два вида "не делайте так"
- Что такое UB
    - Undefined, unspecified, implementation-defined поведение: в чем разница
    - Для чего в языке нужен UB
    - Как искать UB в своем коде
    - Примеры UB
- Что такое ill-formed program
    - IF
    - IFNDR

# Автоматический вывод типов
- auto
- RTTI: typeid, std::type_info

# ПРОЕКТ. Калькулятор алгебраических выражений
- Для строки с алгебраическим выражением, например, "81.0-(2.5+1)/3", вернуть его значение

---
Майлстоун. Вы знаете базовый синтаксис и умеете работать с контейнерами. Можно решать задачи на лееткоде и хакерранке

# Классы: основы
- Поля и методы
- Спецификаторы доступа protected, public, private
- friend
- Отличие классов и структур
- forward declaration

# Конструкторы и деструкторы
- Синтаксис
- Идиома RAII
- Перегрузка конструктора
- Неявное преобразование и explicit
- Спецификаторы =default, =delete

# Поля класса
- Инициализация полей через member initialization list
- this
- static
- Порядок создания и удаления полей (также про исключение про статик)
- const, mutable

# Перегрузка операторов
- Операторы присваивания
- Операторы сравнения
    - Как правильно писать компараторы
- Spaceship operator
- Реализация одних операторов через другие
- Унарные операции
- Инкремент, декремент
- Другие операторы: <<, ...

# Исключения
- Синтаксис
- Как работает раскрутка стека
- Базовая гарантия исключений
- noexcept

# ПРОЕКТ. Класс для представления числа в виде дроби
- Класс для представления числа в виде дроби целых a/b. Перегрузить для него набор операторов

# Обработка ошибок в классах
- Исключения в конструкторах
- Исключения в деструкторах, noexcept
- Как написать класс, соответствующий RAII без исключений

# Семантика копирования и перемещения
- Копирование vs перемещение
- Что такое владение
- Использование std::move()
- rvalue ссылки
- Сравнение производительности

# Реализация копирования и перемещения
- Конструкторы и операторы копирования, перемещения
- Как надо писать конструкторы и операторы копирования, перемещения (сохранение предыдущего состояни при ошибке, пример реализации через swap())
- Правило трех, пяти, нуля
- Аннотация методов
- Идиома Copy and Swap
- Идиома Non-Copyable/Non-Moveable

# Наследование и динамический полиморфизм
- Наследование, переопределение методов
- Абстрактные классы, virtual, override, final
- Таблица виртуальных функций (для одиночного наследования)

# Шаблоны и статический полиморфизм
- Синтаксис объявления шаблонов
- Как работает инстанцирование шаблонов
- decltype
- SFINAE
- Перегрузка функций vs шаблонные функции

# Специализация шаблонов
- Полная специализация шаблонов
- Частичная специализация шаблонов (почему недоступна для функций)

# ПРОЕКТ. TODO: подумать, какой проект здесь подойдет лучше

---
Майлстоун. Вы умеете строить абстракции. Можно заводить пет-проект

# Приведение типов
- Явное и неявное приведение
- c-style cast и его проблемы
- static_cast
- dynamic_cast: RTTI для приведения типов
- const_cast
- reinterpret_cast

# Инициализация: продолжение
- Варианты инициализации
- Most vexing parse
- Списки инициализации
- Агрегаты
- Designated initializers

# Пространства имен
- Что это, какие задачи решают
- using
- Вложенные пространства имен
- ADL

# Распаковка
- std::tie, std::pair
- Structured Binding

# Организация памяти
- Стэк, хип, статическая память
- volatile, static

# Указатели
- Концепция указателя
- nullptr
- Адресная арифметика
- Массивы
- Управление ресурсами, new/delete vs memalloc/free
- Указатели на функции
- Указатели на поля и методы классов
- Идиома pimpl

# Опасности при работе с указателями
- Утечки памяти
    - Освобождение ресурсов в Си-стиле: goto
- Двойное освобождение
- Выход за границы
- Необходимость в RAII и умных указателях

# ПРОЕКТ. Свой класс Строка
- Класс Строка с ограниченным набором методов

# Умные указатели
- unique
- shared
- weak
- make_shared, make_unique

# Невладеющие представления
- std::string_view
- std::span, std::mdspan

---
Майлстоун. Вы знаете важные концепции C++. Можно начинать собеситься на простые вакансии

# Стратегии обработки ошибок
- Иерархия классов исключений
- Когда исключения не подходят
- Ассерты для проверки инвариантов при отладке
- Коды возврата
    - std::error_code
- variant types
    - std::optional
    - std::expected

# Множественное наследование
- Про множественное наследование. Ромбовидное наследование, проблемы
- Виртуальное наследование
- Таблица виртуальных функций (для множественного наследования)

# Вариадики
- Синтаксис вариадиков. Многоточие
- Пакет параметров (Parameter pack)
- sizeof...()
- Выражения свертки (Fold expressions)

# Шаблоны на практике
- Полезные техники использования шаблонов
    - traits (типажи)
    - Стратегии
- Методы сокращения раздувание кода
    - Локальные шаблоны
    - Локальное инстанцирование шаблонов

# ПРОЕКТ. Свой умный указатель
- Простой умный указатель для single-thread использования

# Лямбда-функции
- Мотивация для лямбд: std::find() -> std::find_if(), std::sort() и тд
- Понятия callable object, functor, closure
- Синтаксис лямбды
- Как менялся синтаксис в разных стандартах
- Техники использования лямбд

# Об оптимизациях
- COW. Плюсы и минусы
- Perfect forwarding
- RVO
- NRVO

# Компайл-тайм vs рантайм
- constexpr, consteval, constinit
- if constexpr

# Объединения
- Union'ы и почему их не надо использовать
- Альтернативы union'ам: std::variant, std::any

# Углубленное изучение контейнеров

# Обзор конкурентности в C++
- Потоки, thread_local
- Процессы
- Futures/promises
- Корутины, std::generator
- Модель памяти

# Синхронизация между потоками
- std::atomic
- std::mutex
- std::condition_variable
    - spurious wakeup
- Блокировки
    - std::scoped_lock
    - std::lock_guard
    - std::unique_lock
- std::counting_semaphore, std::binary_semaphore
- std::barriers
- std::latch

# Директивы препроцессора
- define
- ifdef
- ifndef, ...
- Макросы и почему их лучше избегать

# ПРОЕКТ. Поисковый движок
- Сервис с элементарным поисковым движком. Под капотом тред пул, разделяющий тяжелый объект

---
Майлстоун. Вы познакомились с самыми важными аспектами C++. Можно разбираться в опенсорс проектах и не впадать в ступор

# Рейнджи
- Библиотека ranges: обзор
- Объединение операций через пайп
- Алгоритмы
- views
- Адаптеры

# Концепты
- Мотивация
- Семантические требования к параметрам шаблона
- Стандартные концепты
- Варианты использования constraint'ов
- Преимущества концептов
- Практические примеры

# Модули
- Модули vs хедеры
- Собственные модули
- Импорт модулей
- Стандартные модули

# Подкапотная магия компилятора
- Frontend, middle-end, backend
- IR, parse tree, AST, ...
- Подводка к рефлексии

# Интероп C++ и других языков

# Мой код не работает, и я не знаю, почему
- Отладка
    - gdb
- Профилирование
    - valgrind
    - gperftools
- Поиск утечек
    - AddressSanitizer
    - memcheck

# ПРОЕКТ. BadBadMap
Дан класс с самописной мапой. В сишном стиле, с макросами, утечками и другими радостями. Нужно отрефакторить на современный C++

# Куда двигаться дальше
- Какие темы C++ стоит копнуть глубже
    - Конкурентность
    - Шаблоны и концепты
    - Compile-time вычисления
    - ...
- Список полезных ресурсов

---
Майлстоун. Можно считать себя C++ разработчиком