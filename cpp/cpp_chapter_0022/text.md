# Глава 2.2. Операторы

Вы уже читали примеры кода, в которых используется [оператор присваивания](https://en.cppreference.com/w/cpp/language/operator_assignment) `=`, оператор взятия элемента по индексу `[]` и оператор `.` для доступа к члену класса. Рассмотрим ещё несколько категорий операторов, которые пригодятся в первую очередь.

Чтобы поменять порядок выполнения операторов, они группируются скобками:

```cpp
int x = (a + 5) * 8;
```

## Операторы сравнения 

[Операторы сравнения](https://en.cppreference.com/w/cpp/language/operator_comparison) (comparison operators) применимы к большинству фундаментальных типов:
- `==` — равенство.
- `!=` — неравенство.
- `<`, `>` — меньше, больше.
- `<=`, `>=` — меньше или равно, больше или равно.

Выражения сравнения приводятся к типу `bool`. **Выражение** (expression) — это последовательность операторов и операндов.

```cpp
bool a = 8.1 < 16;  // true
bool b = -5 != -5;  // false

std::string s = "";

bool c = s.empty();     // true
bool d = s.size() == 4; // false
```

Чему равно значение `b`? {.task_text}

```cpp  {.example_for_playground .example_for_playground_005}
std::string text = "Operator";

bool b = text[text.size() - 1] == text[3];
```

```consoleoutput {.task_source #cpp_chapter_0022_task_0090}
```
`text.size()` вернёт 8. Символ по индексу 7 равен `r`. Символ по индексу 3 тоже равен `r`. {.task_hint}
```cpp {.task_answer}
true
```

## Логические операторы

[Логические операторы](https://en.cppreference.com/w/cpp/language/operator_logical) применимы ко всем выражениям, которые приводятся к `bool`: 
- `&&` — «И»: `is_filled && is_valid`.
- `||` — «ИЛИ»: `has_gps_location || connected_to_wifi`.
- `!`  — «НЕ» (отрицание): `!is_valid`.

```cpp {.example_for_playground .example_for_playground_001}
bool is_online = true;
bool is_updated = false;

std::println("{}", is_online || is_updated);    // true
std::println("{}", !(is_online && is_updated)); // true
```

XOR — это булева функция, также известная как [исключающее «ИЛИ».](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D1%8E%D1%89%D0%B5%D0%B5_%C2%AB%D0%B8%D0%BB%D0%B8%C2%BB) Она принимает два флага и возвращает `true`, если один из них истинен, а другой — ложен. В остальных случаях она возвращает `false`. {.task_text}

Напишите свою реализацию `hello_xor()`. {.task_text}

```cpp {.task_source #cpp_chapter_0022_task_0050}

```
Функция возвращает `true` тогда и только тогда, когда один из аргументов равен `true`, а другой — `false`. {.task_hint}
```cpp {.task_answer}
bool hello_xor(bool a, bool b)
{
    return (!a && b) || (a && !b);
}
```

## Арифметические операторы

[Арифметические операторы](https://en.cppreference.com/w/cpp/language/operator_arithmetic) (arithmetic operators) применимы к любым выражениям, которые приводятся к числам. Они позволяют осуществлять:
- `+` — сложение: `5 + 6 == 11`.
- `-` — вычитание. `8 - 9 == -1`.
- `*` — умножение. `3 * 7 == 21`.
- `/` — деление.  `10 / 4 == 2`.
- `%` — деление по модулю, то есть получение остатка от деления. `11 % 3 == 2`.

Перечисленные операторы называются бинарными. Они применяются к двум операндам: `a + b`. В C++ есть и унарные операторы — унарные плюс и минус: `+a`, `-a`.

## Возвращаемое значение и побочные эффекты

Операторы удобно рассматривать как функции, а их операнды — как аргументы этих функций. Тогда результат операции — это _возвращаемое значение_ соответствующей «функции».

Упрощённо, _побочный эффект_ оператора — это изменение хотя бы одного из операндов в процессе вычисления оператора.

С арифметическими операторами всё просто: их возвращаемое значение определяется смыслом соответствующего арифметического действия, а побочных эффектов они не имеют. Другое дело — операторы присваивания, в том числе составного. Очевидно, у них есть побочный эффект — это изменение своего левого операнда. Но также они _возвращают_ обновлённое значение своего левого операнда (точнее, ссылку на него, но сейчас это не так важно).

Рассмотрим команду `y = (x += 2);`. Выражение в скобках вернёт изменённое значение переменной `x`, и оно будет присвоено переменной `y`.

## Инкремент и декремент

Увеличение или уменьшение значения на единицу можно записывать ещё короче! [Оператор инкремента](https://en.cppreference.com/w/cpp/language/operator_incdec) `++` увеличивает значение на 1, а оператор декремента `--` уменьшает. Эти операторы применимы _только_ к целым числам.

```cpp
++x; // Эквивалентно x+=1
--x; // Эквивалентно x-=1
```

В этом примере приведена префиксная форма операторов: пре-инкремент и пре-декремент.

Есть и постфиксная форма: в ней `++` и `--` указываются после переменной. Это называется пост-инкрементом и пост-декрементом:

```cpp
x++;
x--;
```

Обе формы имеют один и тот же побочный эффект — они изменяют переменную. Разница в возвращаемом значении.

Префиксный оператор возвращает обновлённое значение переменной: {#block-pre-increment}

```cpp
a = 2;
b = ++a; // a=3, b=3
```

Постфиксный оператор возвращает старое значение переменной:

```cpp
a = 2;
b = a++; // a=3, b=2
```

Постфиксные операторы инкремента и декремента имеют более высокий приоритет, чем префиксные.

И ещё одно важное отличие: префиксные формы возвращают саму переменную, а постфиксные — её неизменяемую копию. Поэтому такой код не скомпилируется:

```cpp
--i++;
```

Вначале выполнится постфиксный оператор и вернёт неизменяемую копию переменной: `--(i++)`. А так как неизменяемое значение нельзя уменьшить, компилятор прервёт сборку программы с ошибкой:

```
error: expression is not assignable
           --i++;
           ^ ~~~
```

## Побитовые операторы

Каждое число в памяти представлено в виде последовательности бит. Например:
- 5 в бинарном виде — это `0b101`,
- 10 — это `0b1010`,
- а 7 — `0b111`.

Префикс `0b` в C++ используется для записи значений в двоичной системе счисления. Если вы плохо с ней знакомы, самое время [восполнить знания.]( https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)

Сколько именно бит в памяти занимает число? Это зависит от типа числа и целевой платформы, под которую компилируется код. Например, под значения типа `std::size_t` _чаще всего_ выделяется 4 байта на 32-битных системах и 8 байт на 64-битных.

Так выглядит в памяти число 3 типа `std::size_t`, занимающее 4 байта:

```
00000000 00000000 00000000 00000011
```

**Побитовые операторы** (bitwise operators) используются для манипуляции _над отдельными битами_ значений. Они применимы только к целым числам. Побитовых операторов всего шесть:
- `~a` — «НЕ»,
- `a & b` — «И»,
- `a | b` — «ИЛИ»,
- `a ^ b` — XOR,
- `a << b` — сдвиг на `b` позиций влево всех битов числа `a`,
- `a >> b` — сдвиг на `b` позиций вправо всех битов `a`.

Многие начинающие разработчики недооценивают побитовые операторы. Однако в реальной практике они активно применяются. Их можно отыскать _во всех_ прикладных областях, а не только в криптографии или разработке микроконтроллеров. Вот популярные, но далеко не единственные сценарии применения битовых операций:
- Быстрая арифметика. В ближайшей [практической работе](/courses/cpp/practice/cpp_div_without_div/) вы сами реализуете деление через побитовые операторы.
- Упаковка данных. Вы можете хранить _несколько_ значений в _одной_ переменной. И в этой главе вы узнаете, как.

### Побитовое отрицание

Оператор `~` — это побитовое «НЕ»: `~a` инвертирует биты числа `a`. Нули становятся единицами, а единицы — нулями. Для знаковых целых чисел, таких как `int`, результат часто оказывается отрицательным. Причина тому — способ представления чисел в памяти компьютера под названием [«Дополнительный код»](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) (two's complement).

Допустим, у нас есть беззнаковое число `x`:

```cpp
std::size_t x = 5;
```

Так оно хранится в памяти, при условии что  `std::size_t` занимает 4 байта:

```
00000000 00000000 00000000 00000101
```

Применим к `x` побитовое отрицание:

```cpp
std::size_t y = ~x;
```

В переменную `y` сохранится последовательность бит:

```
11111111 11111111 11111111 11111010
```

Как видите, это очень большое число. В десятичной системе счисления оно равно `4 145 343 750`. Если бы `std::size_t` занимал 8 байт, а не 4, то число было бы еще больше.

### Побитовые И, ИЛИ и XOR

Операторы `a & b` и `a | b` для побитовых «И» и «ИЛИ» схожи с соответствующими логическими операторами `a && b` и `a || b`, но применяются к числу _побитово._ 

Оператор `&` устанавливает бит 1, если оба соответствующих бита чисел `a` и `b` равны 1:

```cpp
int x = 5 & 6; // 4

// Побитово:
//     101  - 5
//  &  110  - 6
//     ---
//     100  - 4
```

Оператор `|` устанавливает бит 1, если хотя бы один из соответствующих бита чисел `a` и `b` равны 1.

```cpp
int x = 8 | 6; // 14

// Побитово:
//     1000  - 8
//  |  0110  - 6
//     ---
//     1110  - 14
```

У оператора `^` (XOR) нет аналога среди логических операторов. Он устанавливает бит в 1, если соответствующие биты чисел `a` и `b` не равны.

```cpp
int x = 3 ^ 5; // 6

// Побитово:
//     011  - 3
//  ^  101  - 5
//     ---
//     110  - 6
```

### Побитовый сдвиг {#block-bitwise}

Оператор `<<` — это **побитовый сдвиг влево.** Запись вида `x << n` означает, что каждый бит числа `x` сдвигается влево на `n` бит. Освобождающиеся биты заполняются нулями.

Например, если число 3 сдвинуть на 2 бита влево, мы получим 12:

```cpp
3 << 2 // 12
```

Чтобы понять, откуда берётся 12, взглянем на беззнаковое число 3 в двоичном виде:

```
00000000 00000000 00000000 00000011
```

Сдвиг `0b11` на 2 бита влево приводит к тому, что биты числа смещаются в сторону старших разрядов, а на их место устанавливаются нули: `0b1100`.

```
00000000 00000000 00000000 00001100
```

Это и есть 12 в десятичной системе счисления.

Сдвиг числа на один бит влево аналогичен умножению на 2:

```cpp
x << 1 == x * 2
```

Обобщим. Сдвиг числа на `n` бит влево аналогичен умножению на 2 `n` раз, то есть умножению на 2 в степени `n`: `2 ^ n`.

Примеры:

```cpp
4 << 3 // 32
1 << 4 // 16
```

Оператор `>>` — это **побитовый сдвиг вправо.** Запись `x >> n` означает, что биты числа `x` сдвигаются на `n` бит вправо. Для беззнаковых целых, таких как `std::size_t`, освобождающиеся биты заполняются нулями. Для знаковых целых, таких как `int`, поведение определяется реализацией в компиляторе (implementation-defined).

Как можно догадаться, операция сдвига вправо обратна сдвигу влево. И она аналогична целочисленному делению на `2 ^ n`:

```cpp
9  >> 1 // 4
21 >> 2 // 5
```

Приоритет операторов побитового сдвига ниже, чем у сложения `+` и вычитания `-`. Но выше, чем у операторов сравнения `<`, `>`. Таблицу с приоритетом всех операторов вы можете [посмотреть на cppreference.](https://en.cppreference.com/w/cpp/language/operator_precedence)

Для побитовых сдвигов существуют операторы [составного присваивания](/courses/cpp/chapters/cpp_chapter_0022#block-compound-assignment) `<<=` и `>>=`:

```cpp
x <<= n; // эквивалентно x = x << n;
x >>= n; // эквивалентно x = x >> n;
```

Напоследок рассмотрим два нюанса работы со сдвигами. Их знание пригодится вам для выполнения проекта.

### Отбрасывание битов при сдвиге

При побитовом сдвиге влево лишние биты **отбрасываются.** Допустим, у нас есть большое число:

```
01101000 00000000 00000000 00000000
```

Если мы сдвинем его на 1 бит влево, оно увеличится:

```
11010000 00000000 00000000 00000000
```

Но при дальнейшем сдвиге влево старшие разряды потеряются. Они вытеснятся за границы диапазона числа. И вместо того чтобы расти, число наоборот уменьшится:

```
10100000 00000000 00000000 00000000
```

Если применить к получившемуся числу сдвиг влево ещё на 3 бита, число превратится в 0.

### Побитовый сдвиг литералов

По умолчанию целочисленные литералы имеют тип `int`. И такая запись означает сдвиг значения типа `int` на `n` бит влево:

```
5 << n
```

Однако у типов `int` и `std::size_t` разный диапазон значений. Побитовый сдвиг `int` на слишком большое значение, адекватное для `std::size_t`, приведёт к ошибке в вычислениях. Если вы хотите применить сдвиг именно к значению `std::size_t`, воспользуйтесь суффиксом `uz`: {#block-uz}

```
5uz << n
```

[Суффикс uz](https://en.cppreference.com/w/cpp/language/integer_literal) был добавлен в C++23. Он означает, что у литерала тип `std::size_t`. {#block-suffix-uz}

Сравните результаты сдвига на 30 бит влево для значений типа `int` и `std::size_t`:

```cpp
3   << 30 // -1073741824
3uz << 30 // 3221225472
```

Значение типа `int` при побитовом сдвиге влево стало отрицательным из-за уже упомянутого способа представления чисел [«Дополнительный код»](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) (two's complement).


## Составное присваивание {#block-compound-assignment}

[Операторы составного присваивания](https://en.cppreference.com/w/cpp/language/operator_assignment) (compound assignment) объединяют присваивание переменной с арифметическим действием над ней. Их ввели в язык, чтобы записывать простые арифметические действия более кратко:

```cpp
x += 5;  // x = x + 5
x -= y;  // x = x - y
x *= 10; // x = x * 10
x /= y;  // x = x / y
x %= 2;  // x = x % 2
```

Побитовые операторы относятся к арифметическим операторам. И для них тоже существуют варианты составного присваивания:

```cpp
x &= 8;  // x = x & 8
x |= 2;  // x = x | 2
x ^= 4;  // x = x ^ 4
x <<= 2; // x = x << 2
x >>= 1; // x = x >> 1
```


## Приоритет и ассоциативность операторов

Перечислим уже знакомые вам операторы по убыванию приоритета. Если в строке несколько операторов, то приоритет у них одинаковый.
- `a::b` — разрешение области видимости, например `std::println()`. Это оператор с наивысшим приоритетом.
- `a++`, `a--`, `a[b]`, `a.b` — постфиксные инкремент и декремент, взятие по индексу, доступ к члену класса.
- `!a`, `~a`, `+a`, `-a`, `++a`, `--a` — логическое и побитовое отрицание, унарные плюс и минус, префиксные инкремент и декремент.
- `a * b`, `a / b`, `a % b` — умножение, деление, деление по модулю.
- `a + b`, `a - b` — сложение, вычитание.
- `a << b`, `a >> b` — побитовый сдвиг.
- `a < b`, `a <= b`, `a > b`, `a >= b` — больше, меньше.
- `a == b`, `a != b` — равенство, неравенство.
- `a & b` — побитовое «И».
- `a ^ b` — побитовый XOR.
- `a | b` — побитовое «ИЛИ».
- `a && b` — логическое «И».
- `a || b` — логическое «ИЛИ».
- `a = b`, `a += b`, `a -= b`, `a *= b`, `a /= b`, `a %= b` — присваивание, составное присваивание.

Порядок вычисления можно изменять с помощью скобок.

Если рядом стоят два оператора с равным приоритетом, то порядок вычислений определяется ассоциативностью. Так, поскольку `+` — левоассоциативный оператор, то выражение `a + b + c` будет вычисляться как `(a + b) + c.` Оператор присваивания, наоборот, правоассоциативный, именно поэтому присваивание `a = b = 0` работает ожидаемым образом. Ведь оно эквивалентно записи `a = (b = 0).`

Таблицу с приоритетом и ассоциативностью _всех_ операторов C++ вы можете [посмотреть на cppreference.](https://en.cppreference.com/w/cpp/language/operator_precedence)

Нужны ли скобки, чтобы это выражение вычислилось как ожидается? `y/n`. {.task_text}

```cpp
width < 0 || volume / length <= max_val
```

```consoleoutput {.task_source #cpp_chapter_0022_task_0060}
```
Приоритет деления `/` выше, чем сравнения `<=`. А приоритет `||` меньше, чем сравнения. {.task_hint}
```cpp {.task_answer}
n
```

Как быть, если вы сомневаетесь, нужны ли в выражении скобки? [Если без скобок код трудно читать, то ставьте их!](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#res-parens) Например, выражение из задачи выше со скобками выглядит проще: `(width < 0) || (volume / length <= max_val)`.

Какое значение у переменной `x`? {.task_text}

В случае ошибки напишите `err`. {.task_text}

Ремарка: это пример плохого кода. В реальных проектах избегайте подобных трудночитаемых конструкций. Однако они встречаются на собеседованиях. {.task_text}

```cpp  {.example_for_playground .example_for_playground_002}
int a = 1, b = 2, c = 3;
int x = a-- - b++ - c--;
```

```consoleoutput {.task_source #cpp_chapter_0022_task_0070}
```
Приоритет постфиксных операторов выше, чем у оператора вычитания `-`. Постфиксный оператор сначала возвращает значение переменной, а потом изменяет его. Поэтому `x` равен `1 - 2 - 3`. {.task_hint}
```cpp {.task_answer}
-4
```

Что будет выведено в консоль? {.task_text}

В случае ошибки напишите `err`. {.task_text}

```cpp  {.example_for_playground .example_for_playground_003}
int c = 2;
int C = 5;
std::print("{}", c++ * ++C);
```

```consoleoutput {.task_source #cpp_chapter_0022_task_0080}
```
В этом выражении у постфиксного оператора максимальный приоритет. Следующим по приоритету выполнится префиксный оператор. И лишь затем — оператор умножения. Мы получим `2 * 6`. {.task_hint}
```cpp {.task_answer}
12
```

----------

## Резюме

- Операторы сравнения: `==`, `!=`, `<`, `>`, `<=`, `>=`.
- Логические операторы: `&&`, `||`, `!`.
- Арифметические операторы: `+`, `-`, `*`, `/`, `%`.
- Побитовые операторы: `~`, `&`, `|`, `^`, `<<`, `>>`.
- Операторы составного присваивания — это краткая форма выполнения над переменной арифметического действия и присваивания ей. Например, `x *= 2`.
- Операторы инкремента `++` и декремента `--` бывают префиксными и постфиксными.
