# Глава 2.3. Магия побитовых операторов

Побитовые операторы (bitwise operators) нужны для манипуляции _над отдельными битами_ значений. Они применимы только к целым числам.

Некоторые разработчики недооценивают побитовые операторы и побаиваются их. Чтобы развеять туман вокруг этой темы, мы решили уделить ей целую главу.

Побитовые операторы активно применяются в реальной практике. Их можно отыскать _во всех_ прикладных областях, а не только в сжатии данных, криптографии или разработке микроконтроллеров. Вот популярные, но далеко не единственные сценарии применения битовых операций:
- Быстрая арифметика. В ближайшей [практической работе](/courses/cpp/practice/cpp_div_without_div/) вы сами реализуете деление через побитовые операторы.
- Упаковка данных. В _одной_ переменной можно хранить _несколько_ значений, и сейчас вы узнаете, как.

## Бинарное представление чисел

Минимальная адресуемая ячейка памяти — 1 байт. Поэтому размер любой переменной кратен байту. У вас не получится создать переменную размером в 2 бита или 17 бит.  Каждое число в памяти представлено в виде последовательности бит:
- 5 в бинарном виде — это `0b101`,
- 10 — это `0b1010`,
- 7 — это `0b111`, и так далее.

Префикс `0b` в C++ используется для записи значений в двоичной системе счисления. Если вы плохо с ней знакомы, самое время [восполнить знания.]( https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)

Для удобства длинные числа можно разделять апострофом: `0b111'010`.

Сколько именно бит в памяти занимает число? Это зависит от типа числа и целевой платформы, под которую компилируется код. Например, под значения типа `std::size_t` _чаще всего_ выделяется 4 байта на 32-битных системах и 8 байт на 64-битных.

Так выглядит в памяти число 3 типа `std::size_t`, занимающее 4 байта:

```
0b00000000'00000000'00000000'00000011
```

## Какие есть побитовые операторы

Побитовых операторов всего шесть:
- `~a` — побитовое отрицание (инверсия),
- `a & b` — побитовое «И»,
- `a | b` — побитовое «ИЛИ»,
- `a ^ b` — побитовый XOR (взаимоисключающее «ИЛИ»),
- `a << b` — сдвиг битов числа `a` на `b` позиций влево,
- `a >> b` — сдвиг битов числа `a` на `b` позиций вправо.

## Побитовое отрицание

Оператор `~` — это побитовое «НЕ»: `~a` инвертирует биты числа `a`. Нули становятся единицами, а единицы — нулями. Для знаковых целых чисел, таких как `int`, результат часто оказывается отрицательным. Для любопытных: причина тому — способ представления чисел в памяти компьютера под названием [«Дополнительный код»](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) (two's complement).

Допустим, у нас есть беззнаковое число `x`:

```cpp
std::size_t x = 5;
```

При условии что `std::size_t` занимает 4 байта, в памяти `x` представлен следующим образом:

```
0b00000000'00000000'00000000'00000101
```

Применим побитовое отрицание:

```cpp
std::size_t y = ~x;
```

В переменную `y` сохранится последовательность бит:

```
0b11111111'11111111'11111111'11111010
```

Как видите, это очень большое число. В десятичной системе счисления оно равно `4 145 343 750`. Если бы `std::size_t` занимал 8 байт, а не 4, то число было бы еще больше.

Перед вами значение типа `std::size_t` размером в 4 байта. Его бинарное представление: `0b11111111'11111111'11111111'11111100`. {.task_text}

Чему будет равно это число после применения к нему оператора `~`? Ответ запишите в десятичной системе счисления. {.task_text}

```consoleoutput {.task_source #cpp_chapter_0023_task_0010}
```
Оператор `~` инвертирует биты числа и в итоге получится бинарное значение `11`. {.task_hint}
```cpp {.task_answer}
3
```

## Побитовые И, ИЛИ и XOR

Операторы `a & b` и `a | b` для побитовых «И» и «ИЛИ» схожи с соответствующими логическими операторами `a && b` и `a || b`, но применяются к числу _побитово._ 

Оператор `&` устанавливает бит 1, если оба соответствующих бита чисел `a` и `b` равны 1:

```cpp
int x = 5 & 6; // 4

//     0b101  - 5
//  &  0b110  - 6
//     -----
//     0b100  - 4
```

Оператор `|` устанавливает бит 1, если хотя бы один из соответствующих бита чисел `a` и `b` равны 1.

```cpp
int x = 8 | 6; // 14

//     0b1000  - 8
//  |  0b0110  - 6
//     -----
//     0b1110  - 14
```

У оператора `^` (XOR) нет аналога среди логических операторов. Он устанавливает бит в 1, если соответствующие биты чисел `a` и `b` не равны.

```cpp
int x = 3 ^ 5; // 6

//     0b011  - 3
//  ^  0b101  - 5
//     -----
//     0b110  - 6
```

## Побитовый сдвиг {#block-bitwise}

Оператор `<<` — это **побитовый сдвиг влево.** Запись вида `x << n` означает, что каждый бит числа `x` сдвигается влево на `n` бит. Освобожденные биты заполняются нулями.

Например, если число 3 сдвинуть на 2 бита влево, мы получим 12:

```cpp
3 << 2 // 12
```

Чтобы понять, откуда берётся 12, взглянем на беззнаковое число 3 в двоичном виде:

```
0b00000000'00000000'00000000'00000011
```

Сдвиг `0b11` на 2 бита влево приводит к тому, что биты числа смещаются в сторону старших разрядов, а на их место устанавливаются нули: `0b1100`.

```
0b00000000'00000000'00000000'00001100
```

Это и есть 12 в десятичной системе счисления.

Сдвиг числа на один бит влево аналогичен умножению на 2:

```cpp
x << 1 == x * 2
```

Обобщим. Сдвиг числа на `n` бит влево аналогичен умножению на 2 `n` раз, то есть умножению на 2 в степени `n`: `2 ^ n`.

Примеры:

```cpp
4 << 3 // 32
1 << 4 // 16
```

Какое значение сохранится в переменную `x`? {.task_text}

```cpp
int x = 1 << 3;
```

```consoleoutput {.task_source #cpp_chapter_0023_task_0090}
```
Это возведение 2 в степень 3. {.task_hint}
```cpp {.task_answer}
8
```


Оператор `>>` — это **побитовый сдвиг вправо.** Запись `x >> n` означает, что биты числа `x` сдвигаются на `n` бит вправо. Для беззнаковых целых, таких как `std::size_t`, освобождающиеся биты заполняются нулями. Для знаковых целых, таких как `int`, поведение определяется реализацией в компиляторе (implementation-defined).

Как можно догадаться, операция сдвига вправо обратна сдвигу влево. И она аналогична целочисленному делению на `2 ^ n`:

```cpp
9  >> 1 // 4
21 >> 2 // 5
```

Приоритет операторов побитового сдвига ниже, чем у сложения `+` и вычитания `-`. Но выше, чем у операторов сравнения `<`, `>`. Таблицу с приоритетом всех операторов вы можете [посмотреть на cppreference.](https://en.cppreference.com/w/cpp/language/operator_precedence)

Для побитовых сдвигов существуют операторы [составного присваивания](/courses/cpp/chapters/cpp_chapter_0022#block-compound-assignment) `<<=` и `>>=`:

```cpp
x <<= n; // эквивалентно x = x << n;
x >>= n; // эквивалентно x = x >> n;
```

Какое значение сохранится в переменную `x`? {.task_text}

```cpp
int x = 16 >> 4;
```

```consoleoutput {.task_source #cpp_chapter_0023_task_0100}
```
Это деление 16 на 2 в степени 4. {.task_hint}
```cpp {.task_answer}
1
```

Напоследок рассмотрим два нюанса работы со сдвигами.

### Отбрасывание битов при сдвиге

При побитовом сдвиге влево лишние биты **отбрасываются.** Допустим, у нас есть большое число:

```
0b01101000'00000000'00000000'00000000
```

Если мы сдвинем его на 1 бит влево, оно увеличится:

```
0b11010000'00000000'00000000'00000000
```

Но при дальнейшем сдвиге влево старшие разряды потеряются. Они вытеснятся за границы диапазона числа. И вместо того чтобы расти, число наоборот уменьшится:

```
0b10100000'00000000'00000000'00000000
```

Если применить к получившемуся числу сдвиг влево ещё на 3 бита, число превратится в 0.

### Побитовый сдвиг литералов

По умолчанию целочисленные литералы имеют тип `int`. И такая запись означает сдвиг значения типа `int` на `n` бит влево:

```
5 << n
```

Однако у типов `int` и `std::size_t` разный диапазон значений. Побитовый сдвиг `int` на слишком большое значение, адекватное для `std::size_t`, приведёт к ошибке в вычислениях. Если вы хотите применить сдвиг именно к значению `std::size_t`, воспользуйтесь суффиксом `uz`: {#block-uz}

```
5uz << n
```

[Суффикс uz](https://en.cppreference.com/w/cpp/language/integer_literal) был добавлен в C++23. Он означает, что у литерала тип `std::size_t`. {#block-suffix-uz}

Сравните результаты сдвига на 30 бит влево для значений типа `int` и `std::size_t`:

```cpp
3   << 30 // -1073741824
3uz << 30 // 3221225472
```

Значение типа `int` при побитовом сдвиге влево стало отрицательным из-за уже упомянутого способа представления чисел [«Дополнительный код»](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) (two's complement).


## Составное присваивание {#block-compound-assignment}

Побитовые операторы относятся к арифметическим операторам. И для них тоже существуют варианты составного присваивания:

```cpp
x &= 8;  // x = x & 8
x |= 2;  // x = x | 2
x ^= 4;  // x = x ^ 4
x <<= 2; // x = x << 2
x >>= 1; // x = x >> 1
```

## Компактное хранение значений

А теперь перейдем к практическому примеру применения побитовых операторов.

В Unix-системах любому файлу назначаются права. Они определяют, какие с файлом разрешены действия. Допустимо _любое сочетание_ трех вариантов доступа:
- `r` — чтение,
- `w` — запись,
- `x` — выполнение.

Для хранения этих вариантов требуется ровно 3 бита. Перечислим все возможные комбинации:

```
Десятичное   Двоичное   Доступ
число        число

0            0b000      Нет
1            0b001      x
2            0b010      w
3            0b011      w, x
4            0b100      r
5            0b101      r, x
6            0b110      r, w
7            0b111      r, w, x
```

Так, двоичная запись `0b100` означает, что файл доступен только для чтения, а `0b011` — что файл можно записывать и исполнять, но нельзя читать.

Права на файл задаются отдельно для:
- `u` — пользователя-владельца,
- `g` — участников группы-владельца,
- `o` — всех остальных.

Значит, чтобы описать весь набор прав на файл, потребуется 9 бит. Например, у владельца могут быть полные права на файл, у группы — на чтение и запись, а у остальных — только на чтение:

```
Пользователь  Группа  Остальные
0b111         0b110   0b100
```

Если действовать наивно, то для каждого файла на диске придется хранить 9 целых чисел. Но можно сэкономить и выделить под права только одно число. Покажем, как это работает, на примере типа `int`. Он гарантированно занимает не меньше 2-х байт, то есть 16-ти бит. А значит, его с запасом хватит для хранения 9 бит, описывающих доступ.


```cpp
const int user = 7;  // 0b111
const int group = 6; // 0b110
const int other = 4; // 0b100

int rights = 0;

rights = rights | user;  // 0b111

rights = rights << 3;    // 0b111'000

rights = rights | group; // 0b111'110

// TODO: добавление прав other
```

Разберем этот код. Мы завели три значения `user`, `group` и `other` и хотим их упаковать в переменную `rights`. Для наглядности мы сначала инициализировали ее нулем: все биты числа стали равны нулю. После этого мы применили побитовое «ИЛИ» `rights | user`:

```
  0b000  rights
| 0b111  user
  -----
  0b111
```

Затем мы сдвинули получившееся значение `rights` на 3 бита влево `rights << 3`:

```
ob111 << 3 == 0b111'000
```

Тем самым мы освободили крайние 3 бита под запись нового значения `group`: `rights | group`.

```
  0b111'000 rights
| 0b000'110 group
  ---------
  0b111'110
```

Нам осталось по этому же принципу сохранить в переменной `rights` значение `other`.

Вынесем этот пример кода в отдельную функцию `set_rights()`. {.task_text}

Реализуйте ее. Для краткости используйте составное присваивание вместо обычных побитовых операций. Например, `a <<= n` вместо `a = a << n`. {.task_text}

```cpp {.task_source #cpp_chapter_0023_task_0040}
int set_rights(int user, int group, int other)
{
    int rights = 0;

    // Ваш код

    return rights;
}
```
. {.task_hint}
```cpp {.task_answer}
int set_rights(int user, int group, int other)
{
    int rights = user;
    rights <<= 3;
    rights |= group;
    rights <<= 3;
    rights |= other;
    return rights;
}
```

Мы сохранили три числа в одну переменную. Теперь напишем код, который их восстанавливает. Для этого воспользуемся битовой маской.

## Битовые маски

Итак, у нас есть переменная `rights`. Приступим к восстановлению из нее трех значений: прав пользователя `user`, группы `group` и остальных `other`. Действовать будем в порядке, обратном записи.

Сначала прочитаем `other`. Это последние три бита `rights`. Чтобы получить их значение, применим к `rights` побитовый «И» c числом `0b111`.

```cpp
int rights = 500; // 0b111'110'100

const int other = rights & 0b111;
```

Можно сказать, что мы применили к `other` битовую маску.

Битовая маска — это двоичное число для чтения или записи отдельных битов через побитовые операции. Думайте о ней как о трафарете, который накладывается на число, чтобы работать с конкретными битами.

Прочтем значения `group` и `user`. Для этого будем сдвигать `rights` на 3 бита вправо и применять к нему битовую маску.

```cpp
int rights = 500; // 0b111'110'100

const int other = rights & 0b111; // 0b100

rights >>= 3; // 0b111'110
const int group = rights & 0b111; // 0b110

rights >>= 3; // 0b111
const int user = rights & 0b111;  // 0b111
```

Решите задачу извлечения трех чисел из переменной `rights`, не изменяя ее. Для этого вам нужно составить три разные битовые маски, применить их к `rights`, а результат операции сдвинуть на нужное количество бит. {.task_text}

Главное — правильно расставьте скобки: приоритет оператора `>>` выше, чем `&`. Найдите в таблице [на cppreference](https://en.cppreference.com/w/cpp/language/operator_precedence) приоритет всех побитовых операторов. {.task_text}

```cpp {.task_source #cpp_chapter_0023_task_0050}
void print_rights(int rights)
{
    // Ваш код

    std::println("user={} group={} other={}", user, group, other);
}
```
. {.task_hint}
```cpp {.task_answer}
void print_rights(int rights)
{
    const int user = (rights & 0b111'000'000) >> 6;
    const int group = (rights & 0b111'000) >> 3;
    const int user = rights;

    std::println("user={} group={} other={}", user, group, other);
}
```

Права на файл в Unix-стиле — далеко не единственный пример использования побитовых операторов для упаковки и распаковки нескольких значений в одну переменную. Вспомните хотя бы про цветовую модель RGB или ip-адреса. 

## Практика

Какое значение сохранится в переменную `flags`? Ответ введите в двоичном виде без префикса `0b`. {.task_text}

```cpp
int flags = 0b10101;
flags |= (1 << 3);
```

```consoleoutput {.task_source #cpp_chapter_0023_task_0060}
```
Это установка 3-го справа бита `flags`. {.task_hint}
```cpp {.task_answer}
11101
```

Какое значение сохранится в переменную `flags`? Ответ введите в двоичном виде без префикса `0b`. {.task_text}

```cpp
int flags = 0b10101;
flags &= ~(1 << 2);
```

```consoleoutput {.task_source #cpp_chapter_0023_task_0070}
```
Это сброс 2-го справа бита `flags`. {.task_hint}
```cpp {.task_answer}
10001
```

Какое значение сохранится в переменную `flags`? Ответ введите в двоичном виде без префикса `0b`. {.task_text}

```cpp
int flags = 0b10101;
flags ^= (1 << 4);
```

```consoleoutput {.task_source #cpp_chapter_0023_task_0080}
```
Это инверсия 4-го справа бита `flags`. {.task_hint}
```cpp {.task_answer}
101
```

Напишите функцию, которая проверят, включен ли `n`-ный бит числа `x`. Не забудьте суффикс `uz` для литерала. {.task_text}

```cpp {.task_source #cpp_chapter_0023_task_0100}
bool is_on(std::size_t x, std::size_t n)
{

}
```
Примените битовую маску: бит `1`, сдвинутый на `n` позиций влево. Бит установлен в 1, если побитовый «И» числа с этой маской равен `1`.{.task_hint}
```cpp {.task_answer}
bool is_on(std::size_t x, std::size_t n)
{
  return x & (1uz << n);
}
```

----------

## Резюме

- Побитовые операторы (bitwise operators) позволяют работать с _отдельными битами_ целых чисел.
- Побитовые операторы:
  - `~` — инверсия бита,
  - `&` — «И»,
  - `|` — «ИЛИ»,
  - `^` — XOR,
  - `<<` — побитовый сдвиг вправо,
  - `>>` — побитовый сдвиг влево.
- Операция `x << n` равносильна умножению `x` на 2 в степени `n`.
- Операция `x >> n` равносильна целочисленному делению `x` на 2 в степени `n`.
- Битовые маски применяются в сочетании с побитовыми операторами для доступа к конкретным битам.
