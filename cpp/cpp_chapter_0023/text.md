# Глава 2.3. Магия побитовых операторов

Побитовые операторы (bitwise operators) нужны для манипуляции _над отдельными битами_ значений. Они применимы только к целым числам.

Некоторые разработчики недооценивают побитовые операторы и побаиваются их. Чтобы развеять туман вокруг этой темы, мы решили уделить ей целую главу. Побитовые операторы активно применяются в реальной практике. Их можно отыскать _во всех_ прикладных областях, а не только в криптографии или разработке микроконтроллеров. Вот популярные, но далеко не единственные сценарии применения битовых операций:
- Быстрая арифметика. В ближайшей [практической работе](/courses/cpp/practice/cpp_div_without_div/) вы сами реализуете деление через побитовые операторы.
- Упаковка данных. В _одной_ переменной можно хранить _несколько_ значений, и в этой главе вы узнаете, как.

## Бинарное представление чисел

Каждое число в памяти представлено в виде последовательности бит:
- 5 в бинарном виде — это `0b101`,
- 10 — это `0b1010`,
- 7 — это `0b111`, и так далее.

Префикс `0b` в C++ используется для записи значений в двоичной системе счисления. Если вы плохо с ней знакомы, самое время [восполнить знания.]( https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)

Сколько именно бит в памяти занимает число? Это зависит от типа числа и целевой платформы, под которую компилируется код. Например, под значения типа `std::size_t` _чаще всего_ выделяется 4 байта на 32-битных системах и 8 байт на 64-битных.

Так выглядит в памяти число 3 типа `std::size_t`, занимающее 4 байта:

```
00000000 00000000 00000000 00000011
```

## Какие есть побитовые операторы

Побитовых операторов всего шесть:
- `~a` — побитовое отрицание (инверсия битов),
- `a & b` — побитовое «И»,
- `a | b` — побитовое «ИЛИ»,
- `a ^ b` — побитовый XOR (взаимоисключающее «ИЛИ»),
- `a << b` — сдвиг битов числа `a` на `b` позиций влево,
- `a >> b` — сдвиг битов числа `a` на `b` позиций вправо.

## Побитовое отрицание

Оператор `~` — это побитовое «НЕ»: `~a` инвертирует биты числа `a`. Нули становятся единицами, а единицы — нулями. Для знаковых целых чисел, таких как `int`, результат часто оказывается отрицательным. Для любопытных: причина тому — способ представления чисел в памяти компьютера под названием [«Дополнительный код»](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) (two's complement).

Допустим, у нас есть беззнаковое число `x`:

```cpp
std::size_t x = 5;
```

При условии что `std::size_t` занимает 4 байта, в памяти `x` представлен следующим образом:

```
00000000 00000000 00000000 00000101
```

Применим побитовое отрицание:

```cpp
std::size_t y = ~x;
```

В переменную `y` сохранится последовательность бит:

```
11111111 11111111 11111111 11111010
```

Как видите, это очень большое число. В десятичной системе счисления оно равно `4 145 343 750`. Если бы `std::size_t` занимал 8 байт, а не 4, то число было бы еще больше.

Перед вами значение типа `std::size_t` размером в 4 байта. Его бинарное представление: `11111111 11111111 11111111 11111100`. {.task_text}

Чему будет равно это число после применения к нему оператора `~`? Ответ запишите в десятичной системе счисления. {.task_text}

```consoleoutput {.task_source #cpp_chapter_0023_task_0010}
```
Оператор `~` инвертирует биты числа и в итоге получится бинарное значение `11`. {.task_hint}
```cpp {.task_answer}
3
```

## Побитовые И, ИЛИ и XOR

Операторы `a & b` и `a | b` для побитовых «И» и «ИЛИ» схожи с соответствующими логическими операторами `a && b` и `a || b`, но применяются к числу _побитово._ 

Оператор `&` устанавливает бит 1, если оба соответствующих бита чисел `a` и `b` равны 1:

```cpp
int x = 5 & 6; // 4

//     101  - 5
//  &  110  - 6
//     ---
//     100  - 4
```

Оператор `|` устанавливает бит 1, если хотя бы один из соответствующих бита чисел `a` и `b` равны 1.

```cpp
int x = 8 | 6; // 14

//     1000  - 8
//  |  0110  - 6
//     ---
//     1110  - 14
```

У оператора `^` (XOR) нет аналога среди логических операторов. Он устанавливает бит в 1, если соответствующие биты чисел `a` и `b` не равны.

```cpp
int x = 3 ^ 5; // 6

//     011  - 3
//  ^  101  - 5
//     ---
//     110  - 6
```

## Побитовый сдвиг {#block-bitwise}

Оператор `<<` — это **побитовый сдвиг влево.** Запись вида `x << n` означает, что каждый бит числа `x` сдвигается влево на `n` бит. Освобожденные биты заполняются нулями.

Например, если число 3 сдвинуть на 2 бита влево, мы получим 12:

```cpp
3 << 2 // 12
```

Чтобы понять, откуда берётся 12, взглянем на беззнаковое число 3 в двоичном виде:

```
00000000 00000000 00000000 00000011
```

Сдвиг `0b11` на 2 бита влево приводит к тому, что биты числа смещаются в сторону старших разрядов, а на их место устанавливаются нули: `0b1100`.

```
00000000 00000000 00000000 00001100
```

Это и есть 12 в десятичной системе счисления.

Сдвиг числа на один бит влево аналогичен умножению на 2:

```cpp
x << 1 == x * 2
```

Обобщим. Сдвиг числа на `n` бит влево аналогичен умножению на 2 `n` раз, то есть умножению на 2 в степени `n`: `2 ^ n`.

Примеры:

```cpp
4 << 3 // 32
1 << 4 // 16
```

Оператор `>>` — это **побитовый сдвиг вправо.** Запись `x >> n` означает, что биты числа `x` сдвигаются на `n` бит вправо. Для беззнаковых целых, таких как `std::size_t`, освобождающиеся биты заполняются нулями. Для знаковых целых, таких как `int`, поведение определяется реализацией в компиляторе (implementation-defined).

Как можно догадаться, операция сдвига вправо обратна сдвигу влево. И она аналогична целочисленному делению на `2 ^ n`:

```cpp
9  >> 1 // 4
21 >> 2 // 5
```

Приоритет операторов побитового сдвига ниже, чем у сложения `+` и вычитания `-`. Но выше, чем у операторов сравнения `<`, `>`. Таблицу с приоритетом всех операторов вы можете [посмотреть на cppreference.](https://en.cppreference.com/w/cpp/language/operator_precedence)

Для побитовых сдвигов существуют операторы [составного присваивания](/courses/cpp/chapters/cpp_chapter_0022#block-compound-assignment) `<<=` и `>>=`:

```cpp
x <<= n; // эквивалентно x = x << n;
x >>= n; // эквивалентно x = x >> n;
```

Напоследок рассмотрим два нюанса работы со сдвигами.

### Отбрасывание битов при сдвиге

При побитовом сдвиге влево лишние биты **отбрасываются.** Допустим, у нас есть большое число:

```
01101000 00000000 00000000 00000000
```

Если мы сдвинем его на 1 бит влево, оно увеличится:

```
11010000 00000000 00000000 00000000
```

Но при дальнейшем сдвиге влево старшие разряды потеряются. Они вытеснятся за границы диапазона числа. И вместо того чтобы расти, число наоборот уменьшится:

```
10100000 00000000 00000000 00000000
```

Если применить к получившемуся числу сдвиг влево ещё на 3 бита, число превратится в 0.

### Побитовый сдвиг литералов

По умолчанию целочисленные литералы имеют тип `int`. И такая запись означает сдвиг значения типа `int` на `n` бит влево:

```
5 << n
```

Однако у типов `int` и `std::size_t` разный диапазон значений. Побитовый сдвиг `int` на слишком большое значение, адекватное для `std::size_t`, приведёт к ошибке в вычислениях. Если вы хотите применить сдвиг именно к значению `std::size_t`, воспользуйтесь суффиксом `uz`: {#block-uz}

```
5uz << n
```

[Суффикс uz](https://en.cppreference.com/w/cpp/language/integer_literal) был добавлен в C++23. Он означает, что у литерала тип `std::size_t`. {#block-suffix-uz}

Сравните результаты сдвига на 30 бит влево для значений типа `int` и `std::size_t`:

```cpp
3   << 30 // -1073741824
3uz << 30 // 3221225472
```

Значение типа `int` при побитовом сдвиге влево стало отрицательным из-за уже упомянутого способа представления чисел [«Дополнительный код»](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) (two's complement).


## Составное присваивание {#block-compound-assignment}

Побитовые операторы относятся к арифметическим операторам. И для них тоже существуют варианты составного присваивания:

```cpp
x &= 8;  // x = x & 8
x |= 2;  // x = x | 2
x ^= 4;  // x = x ^ 4
x <<= 2; // x = x << 2
x >>= 1; // x = x >> 1
```

## Битовые маски

В Unix-системах любому файлу назначаются права. Они определяют, что с файлом можно делать. Допустимо _любое сочетание_ трех вариантов доступа:
- `r` - чтение,
- `w` - запись,
- `x` - выполнение.

Для хранения этих вариантов требуется ровно 3 бита. Перечислим все возможные комбинации:

```
Десятичное   Двоичное   Доступ
число        число

0            000        Нет
1            001        x
2            010        w
3            011        w, x
4            100        r
5            101        r, x
6            110        r, w
7            111        r, w, x
```

Так, двоичная запись `100` означает, что файл доступен только для чтения, а `011` - что файл можно записывать исполнять, но нельзя читать.

Права задаются отдельно для:
- `u` - пользователя-владельца,
- `g` - участников группы-владельца,
- `o` - всех остальных.

Чтобы описать весь набор прав на файл, потребуется 9 бит. Например, у владельца могут быть полные права на файл, у группы - на чтение и запись, а у остальных - только на чтение:

```
Пользователь Группа Остальные
111          110    100
```

Если действовать наивно, то для каждого файла на диске придется хранить 9 целых чисел. А лучше сэкономить и завести под права только одно число. Продемонстрируем, как это работает, на примере типа `int`. Он гарантированно занимает не меньше 2-х байт, то есть 16-ти бит.



----------

## Резюме

- Побитовые операторы: `~`, `&`, `|`, `^`, `<<`, `>>`.
