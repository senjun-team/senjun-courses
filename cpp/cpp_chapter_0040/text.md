# Глава 4. Сборка проекта

Чтобы из проекта с исходным кодом на C++ собрать исполняемый файл или библиотеку, компилятор выполняет несколько шагов. На каждом из них сборка может прерваться с ошибкой. Сможете ли вы понять причину и устранить ошибку? Зависит от того, насколько детально вы представляете процесс сборки программы.

## Организация проекта

Как правило проект на C++ содержит файлы трех типов:
- Заголовочные файлы (хедеры). Им принято давать расширение `.h` или `.hpp`.
- Файлы реализации. Чаще всего у них расширение `.cpp`, `.cxx` или `.cc`.
- Файлы, специфичные для системы сборки.

В хедерах размещаются объявления функций, классов и других сущностей. Файлы реализации содержат их определения. У этого правила есть исключения: в некоторых случаях определения можно или даже нужно размещать в хедерах.

В простейшем случае проект — это единственный файл реализации, из которого получается исполняемый файл. Или единственный хедер, если проект — библиотека. С другой стороны, проект на C++ может быть сколь угодно сложным и содержащим произвольную иерархию директорий.

## Что такое компиляция

Для того, чтобы запустить программу на C++, ее нужно **скомпилировать** — из файлов с исходным кодом получить исполняемый файл для целевой платформы. Этот файл содержит **бинарный код** — машинные команды для конкретной архитектуры процессора. Артефактом сборки библиотеки тоже является бинарный файл. Файлы с бинарным кодом иногда называют **бинарями.**

Важно понимать, что бинарные файлы не переносимы между разными системами. Нельзя собрать исполняемый файл под процессор ARM и запустить на Intel x86. Библиотека, собранная под Linux, не может быть переиспользована в Windows. И на то есть несколько причин, которые мы рассмотрим в этой главе.

Сам C++ конечно кроссплатформенный: скомпилировать программу на C++ можно практически под любую платформу. Если целевая платформа отличается от той, на которой происходит сборка, то такой процесс называется **кросс-компиляцией.** Тот факт, что язык кросплатформенный, не дает гарантии, что конкретная программа на нем тоже кросплатформенная. Напротив, для разработки действительно кросс-платформенных проектов нужно прилагать усилия. Какие именно — обсудим в следующих главах.

Сборка программы на C++ состоит из нескольких стадий, за которые отвечают препроцессор, компилятор, ассемблер и линковщик. Цепочка вызова этих инструментов скрыта от разработчика фасадом — **драйвером компилятора** (compiler driver). Для того, чтобы собрать проект, нужно вызвать драйвер компилятора, и он позаботится обо всем остальном.

Для краткости драйвер компилятора практически всегда называют просто компилятором. Поэтому в зависимости от контекста под **компилятором** подразумевается как вся система сборки целиком, так и отдельный ее компонент.

## Компиляторы C++

В подавляющем [большинстве](https://www.jetbrains.com/lp/devecosystem-2023/cpp/#cpp_compilers) проектов на C++ сборка осуществляется одним из этих компиляторов: GCC, Clang, Apple Clang, MSVC.

[GCC](https://gcc.gnu.org/) (GNU Compiler Collection) — набор компиляторов для множества языков программирования. Разрабатывается в рамках [проекта GNU.](https://www.gnu.org/)

[Clang](https://clang.llvm.org/) — компилятор семейства C-подобных языков под зонтиком проекта [LLVM.](https://www.llvm.org/)

[Apple Clang](https://opensource.apple.com/projects/llvm-clang/) — проприетарная модификация Clang для продукции Apple.

[MSVC](https://visualstudio.microsoft.com/vs/features/cplusplus/) (Microsoft Visual C++) — компилятор от Microsoft. Программы на C++ под Windows чаще всего собираются именно с его помощью.

![Лого компиляторов](https://raw.githubusercontent.com/senjun-team/senjun-courses/introduce-cpp/illustrations/cpp/cpp_compilers.png) {.illustration}

По распространенности лидирует GCC и в этом курсе мы будем использовать его. Это стандартный компилятор для свободных *nix-подобных ОС. Именно GCC собирает ядро Linux. На cppreference постоянно актуализируется [список фичей](https://en.cppreference.com/w/cpp/compiler_support) версий C++ в разрезе поддержки компиляторами. И по скорости поддержки новых стандартов GCC часто лидирует.

В коллекции проекта GCC есть драйверы компилятора gcc и g++. Оба умеют собирать проекты на C и на C++. При сборке проекта на C++ их различия сводятся к опциям по умолчанию.

## Пайплайн компиляции

Драйвер компилятора последовательно вызывает несколько инструментов: препроцессор, компилятор, ассемблер и линковщик. С их помощью из исходного кода на C++ создается исполняемый файл или библиотека:

![Пайплайн сборки](https://raw.githubusercontent.com/senjun-team/senjun-courses/introduce-cpp/illustrations/cpp/cpp_build_pipeline.jpg) {.illustration}

Процесс компиляции для исполняемых файлов и библиотек принципиально не отличается.

### Препроцессор

Препроцессор (preprocessor) запускается первым и поштучно обрабатывает файлы реализации. Он обращается к заголовочным файлам, если они подключены в файлы реализации. На выходе препроцессор формирует единицы трансляции. Иногда их называют единицами компиляции.

**Единица трансляции** (translation unit) — это обработанный препроцессором файл реализации. В него добавлены все хедеры, которые файл включает прямо или косвенно. На каждую единицу трансляции препроцессор создает промежуточный файл, который затем читается компилятором.

Препроцессор выполняет [лексический анализ](https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7) — разбор кода на лексемы.  Лексема — это неделимая значимая единица кода, такая как имя переменной, оператор, ключевое слово, комментарий. После лексического анализа у препроцессора достаточно информации, чтобы обнаружить и обработать директивы препроцессора.

**Директива препроцессора** — строка в коде, начинающаяся с символа `#`, за которым следует ключевое слово и опционально параметры:

```c++
#keyword params
```

Например, ключевое слово `include` заменяет строку с директивой содержимым файла. Имя файла — обязательный параметр для ключевого слова `include`:

```c++
#include <iostream>

#include "common/logging.hpp"
```

Директиву `#include` принято использовать для подключения хедеров. Но она сработает для произвольного файла, будь то `.cpp`, `.txt` или `.json`.

А ключевое слово `define` объявляет **макрос** — фрагмент кода, которому дано имя директивной `#define` для использования этого фрагмента по имени. Препроцессор находит все использования макроса и заменяет их на соответствующий этому имени блок кода.

Заведем макрос `PI` и используем его при выводе в консоль:

```c++  {.example_for_playground}
#include <iostream>

#define PI 3.1415926

int main() {
  double x = 2.0;

  std::cout << PI << std::endl;

  return 0;
}
```
```
3.1415926
```

После обработки этого кода препроцессором директива `#define` исчезнет, а по месту ее использования произойдет **макроподстановка:**

```c++
std::cout << 3.1415926 << std::endl;
```

Директивы препроцессора мы рассмотрим более детально в посвященной им главе. А сейчас главное запомнить, что препроцессор обрабатывает эти директивы и буквально *переписывает код:*
- Вместо директивы `#include filename` рекурсивно подставляет содержимое файла `filename`. Рекурсивно — потому что один хедер в свою очередь может включать другие хедеры.
- Выполняет макроподстановки: вместо макроса, объявленного через директиву `#define`, по месту использования макроса вставляет его тело.
- Изменяет код в соответствии с директивами условной компиляции `#if`, `#ifdef` и `#ifndef`.
- Выводит сообщения, расставленные по коду такими директивами как `#warning` и `#error`.
- Выполняет простые замены в коде. Например, вместо комментариев вставляет пустые строки.
- Размечает код для компилятора: расставляет маркеры, подсказывающие, из какого файла какая строка была подставлена. Компилятор запускается после препроцессора и использует эту информацию при выводе ошибок.

В конце своей работы препроцессор сохраняет промежуточные файлы с проведенными подстановками и добавленной разметкой. На одну единицу трансляции приходится по одному промежуточному файлу с расширением `.ii` или  `.i`.

Проведем эксперимент. Создадим проект на C++, состоящий из единственного файла main.cpp. В нем определена и использована функция, реализующая [алгоритм Евклида](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%B0) для поиска наибольшего общего делителя (greatest common divisor, GCD) двух целых чисел.

Для того чтобы ссылаться на этот проект на протяжении всей главы, дадим ему имя gcd.

Содержимое main.cpp:

```c++  {.example_for_playground}
#include <iostream>

int gcd(int a, int b) 
{
    while (b != 0) 
    {
        if (a > b)
            a = a - b;
        else
            b = b - a;
    }

    return a;
}

int main()
{
    std::cout << gcd(105, 252) << std::endl;
}
```
```
21
```

Давайте посмотрим, сколько строк окажется в промежуточном файле единицы трансляции. Для этого в консоли вызовем драйвер компилятора g++ с опцией `-E`, останавливающей сборку после препроцессинга. А затем воспользуемся командой [wc](https://linux.die.net/man/1/wc) (word count) для подсчета количества строк (`-l`, lines) в файле:

```shell
g++ -E main.cpp -o main.i
wc -l main.i
```
```
36986 main.i
```

Ого, из нескольких строк кода мы получили десятки тысяч! И это для маленького файла, подключающего всего один хедер. А все благодаря директиве `#include`, вместо которой препроцессор рекурсивно скопировал содержимое файла `iostream`. А если в проекте сотни файлов, и каждый из них подключает десятки хедеров? Неудивительно, что компиляция крупных проектов длится минуты и даже десятки минут!

В проекте есть 3 файла реализации и 2 хедера. Каждый из хедеров подключен во все файлы реализации. Сколько раз в итоге препроцессор будет подставлять содержимое файла по месту директивы `#include`? {.task_text}

```consoleoutput {.task_source #cpp_chapter_0040_task_0010}
```
Препроцессор обрабатывает каждый файл реализации по отдельности. И каждый раз по месту директивы `#include` подставляет содержимое соответствующего заголовочного файла.  Поэтому каждый из 2-х хедеров будет подставлен трижды. Итого 6 раз. {.task_hint}
```cpp {.task_answer}
6
```

Содержимое хедера может попасть в файл реализации несколько раз. И не обязательно из-за ошибки. Например, если помимо хедера А подключен хедер Б, который тоже в свою очередь подключает А, прямо или косвенно.

Многократная обработка одних и тех же хедеров — _настоящая проблема._ Она приводит к разрастанию объема единиц трансляции и следовательно к медленной компиляции. Ведь после препроцессора запускается компилятор, который весь этот код снова парсит, оптимизирует и транслирует в ассемблер.

![Медленная компиляция](https://raw.githubusercontent.com/senjun-team/senjun-courses/introduce-cpp/illustrations/cpp/slow_compiling.jpg) {.illustration}

Повторное включение одного и того же кода чревато ошибками компиляции. Из-за него появляются конфликтующие объявления и определения. Значит, такой код не будет скомпилирован. Чтобы этого избежать, содержимое хедера оборачивается специальной директивной препроцессора для защиты от повторного подключения (include guard). О ней мы поговорим в главе про директивы препроцессора.

Если макросы с одинаковым именем определяются в нескольких хедерах, то от _порядка включения_ хедеров зависит, тело какого макроса будет использовано в коде.

Со всеми перечисленными проблемами призваны бороться модули. О них в этом курсе тоже будет рассказано.

Итак, препроцессор сохраняет единицы трансляции в промежуточные файлы, и их подхватывает компилятор.

### Компилятор

Компиляция — ключевой шаг сборки проекта. Задача компилятора (compiler) — поштучно распарсить единицы трансляции, оптимизировать их и транслировать каждый из этих файлов в ассемблер.

Кроме того, компилятор умеет _генерировать_ новый код, а некоторый код даже _выполнять!_

Генерация кода проводится для шаблонных функций и классов: компилятор инстанцирует шаблоны, то есть порождает специализации шаблонов для конкретных параметров. Специализация — это частный случай шаблона для определенного типа.

Компилятор не только генерирует код, но и модифицирует существующий: некоторые имена переменных, функций и типов заменяются по набору правил. Дело в том, что в C++ допустима перегрузка функций — заведение функций с одинаковыми именами, но разными параметрами. Кроме того, разные переменные или классы с одним и тем же именем могут быть объявлены в разных областях видимости. Для того, чтобы однозначно идентифицировать именованные сущности в коде, компилятор добавляет к имени информацию о неймспейсе, принимаемых функцией параметрах и их типах. Это называется [искажением имен](https://en.wikipedia.org/wiki/Name_mangling) (name mangling).

Исполнение кода на этапе компиляции (compile-time) достигается при использовании по отдельности или в комбинации:
- шаблонного метапрограммирования,
- ключевых слов `constinit`, `consteval` и `constexpr` для вычисления выражений и исполнения функций на этапе компиляции, а не в рантайме.

Компилятор проводит три вида анализа кода:
- Лексический.
- Синтаксический (грамматический).
- Семантический (смысловой).

Начинается все с [лексического анализа](https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7), то есть с разбивки текста на лексемы. Лексический анализ — ранний этап компиляции, но уже на нем компилятор способен сообщить о некоторых синтаксических ошибках, например опечатках в ключевых словах и операторах. По каждому входному файлу лексер (компонент, занимающийся лексическим анализом) выстраивает последовательность лексем.

Эта последовательность нужна для [синтаксического анализа](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7) — сопоставления цепочки лексем с формальной грамматикой языка. На этом этапе компилятор сообщает об ошибках, которые не смог найти лексер: о незакрытой скобке, использовании необъявленной переменной, пропущенной точке с запятой и об остальных синтаксических ошибках.

Компилятор может сообщить о нарушении [ODR](/courses/cpp/chapters/cpp_chapter_0030/) (one definition rule, правило одного определения). Так как он обрабатывает каждую единицу трансляции отдельно, то находит повторные определения только внутри одной единицы трансляции. Нарушения ODR *между* единицами трансляции определяет линковщик.

По ходу синтаксического анализа компилятор строит из кода дерево разбора (parse tree). Это ориентированное дерево, в котором внутренние вершины — операторы, а листья — соответствующие им операнды, то есть переменные и константы. Иными словами, структура программы отображается в виде дерева из объявлений, инструкций и выражений.

Затем дерево разбора урезается до AST (abstract syntax tree, абстрактное синтаксическое дерево). AST отличается от дерева разбора тем, что в нем отсутствуют не влияющие на семантику программы узлы. Например, группирующие скобки. Потери важной информации при этом не происходит, ведь группировка операндов и так задается древовидной структурой.

Рассмотрим фрагмент кода из проекта gcd для нахождения наибольшего общего делителя целых чисел `a` и `b`:

```c++
    while (b != 0) 
    {
        if (a > b)
            a = a - b;
        else
            b = b - a;
    }

    return a;
```

В упрощенном виде AST для этого кода будет выглядеть так:

![Пример AST](https://raw.githubusercontent.com/senjun-team/senjun-courses/introduce-cpp/illustrations/cpp/ast_for_euclidean_algo.jpg) {.illustration}

AST обходится при [семантическом анализе](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BC%D0%B0%D0%BD%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7) кода. На этом этапе компилятор сообщает о неверных программных конструкциях. Например, о вызове функции с неправильным количеством аргументов.

В этом коде допущена семантическая ошибка. Исправьте ее, чтобы вывод в консоль соответствовал ожидаемому. {.task_text}

```c++ {.task_source #cpp_chapter_0040_task_0020}
#include <iostream>

int main()
{
    int a = 6;
    int b = 10;
    int res;
    
    a + b = res;
    std::cout << res << std::endl; // 16
}
```
Проблема в строке `a + b = res;`. По левую сторону от оператора `=` оказалось выражение, которому бессмысленно делать присваивание. {.task_hint}
```c++ {.task_answer}
#include <iostream>

int main()
{
    int a = 6;
    int b = 10;
    int res = a + b;
    
    std::cout << res << std::endl; // 16
}
```

После семантического анализа стартует этап кодогенерации. Компилятор вновь обходит AST и генерирует промежуточное представление кода, над которым удобно проводить **оптимизации.** Так как единица трансляции — это файл, то все оптимизации компилятор выполняет в рамках одного файла. Вариантов оптимизаций насчитываются сотни. В качестве примера можно привести встраивание функций (inlining) — подстановку тела функции по месту ее вызова.

То, насколько агрессивно компилятор будет оптимизировать код, задается соответствующими [опциями.](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html) Так, `-O0` означает отсутствие любых оптимизаций для дебаг-сборки, а `-O3` — максимальный набор всех возможных оптимизаций.

После того, как оптимизации завершены, из промежуточного представления для каждой единицы трансляции создается файл с кодом на ассемблере.

Продолжим экспериментировать со сборкой проекта gcd. Запустим ее с опцией `-S`, останавливающей процесс после компиляции. Командой [cat](https://linux.die.net/man/1/cat) выведем содержимое файла с ассемблером в консоль.

```shell
g++ -S main.cpp
cat main.s
```
```
        .file   "main.cpp"
        .text
#APP
        .globl _ZSt21ios_base_library_initv
#NO_APP
        .globl  _Z3gcdii
        .type   _Z3gcdii, @function
_Z3gcdii:
.LFB2012:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    %edi, -4(%rbp)
        movl    %esi, -8(%rbp)
        jmp     .L2
.L4:
        movl    -4(%rbp), %eax
        cmpl    -8(%rbp), %eax
        jle     .L3
        movl    -8(%rbp), %eax
        subl    %eax, -4(%rbp)
        jmp     .L2
.L3:
        movl    -4(%rbp), %eax
        subl    %eax, -8(%rbp)
.L2:
        cmpl    $0, -8(%rbp)
        jne     .L4
        movl    -4(%rbp), %eax
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE2012:
        .size   _Z3gcdii, .-_Z3gcdii
        .globl  main
        .type   main, @function
main:
.LFB2013:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    $252, %esi
        movl    $105, %edi
        call    _Z3gcdii
        movl    %eax, %esi
        movl    $_ZSt4cout, %edi
        call    _ZNSolsEi
        movl    $_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, %esi
        movq    %rax, %rdi
        call    _ZNSolsEPFRSoS_E
        movl    $0, %eax
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
...
```

Десятки тысяч строк кода были транслированы в десятки строк на ассемблере.

### Ассемблер

После компилятора запускается ассемблер (assembler): он поштучно транслирует файлы на ассемблере в машинный код — платформозависимый бинарный код, содержащий команды для конкретной архитектуры процессора. Ассемблер сохраняет машинный код в **объектные файлы** (object files). Каждой единице трансляции после этого соответствует один объектный файл.

Запустим сборку проекта gcd с опцией `-с`, останавливающей процесс после вызова ассемблера. С помощью команды [xxd](https://linux.die.net/man/1/xxd) посмотрим на содержимое получившегося объектного файла в шестнадцатеричном представлении (hexdump).

```shell
g++ -c main.cpp
xxd main.o
```
```
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0100 3e00 0100 0000 0000 0000 0000 0000  ..>.............
00000020: 0000 0000 0000 0000 d004 0000 0000 0000  ................
00000030: 0000 0000 4000 0000 0000 4000 0e00 0d00  ....@.....@.....
00000040: 5548 89e5 897d fc89 75f8 eb16 8b45 fc3b  UH...}..u....E.;
00000050: 45f8 7e08 8b45 f829 45fc eb06 8b45 fc29  E.~..E.)E....E.)
00000060: 45f8 837d f800 75e4 8b45 fc5d c355 4889  E..}..u..E.].UH.
00000070: e5be fc00 0000 bf69 0000 00e8 0000 0000  .......i........
00000080: 89c6 bf00 0000 00e8 0000 0000 be00 0000  ................
00000090: 0048 89c7 e800 0000 00b8 0000 0000 5dc3  .H............].
000000a0: 0101 0100 4743 433a 2028 5355 5345 204c  ....GCC: (SUSE L
000000b0: 696e 7578 2920 3134 2e32 2e30 0000 0000  inux) 14.2.0....
000000c0: 0400 0000 2000 0000 0500 0000 474e 5500  .... .......GNU.
000000d0: 0200 01c0 0400 0000 0000 0000 0000 0000  ................
000000e0: 0100 01c0 0400 0000 0100 0000 0000 0000  ................
...
```

В первых байтах файла зашит его формат. В мире *nix для объектных файлов, исполняемых файлов и библиотек распространен двоичный формат под названием [ELF](https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format) (Executable and Linking Format, формат исполнимых и компонуемых файлов). В мире Windows используются форматы [COFF](https://ru.wikipedia.org/wiki/COFF) (Common Object File Format) для объектных файлов и [PE](https://ru.wikipedia.org/wiki/Portable_Executable) (Portable Executable) для исполняемых.

### Линковщик

Линковка (компоновка) — это финальный этап сборки программы. До него каждый файл реализации проходит сборку обособленно от других файлов. На этапе линковки объектные файлы объединяются в исполняемый файл или библиотеку. При этом они компонуются:
- друг с другом, 
- с используемыми в них библиотеками, 
- с рантаймом C и C++ — набором библиотек, реализующих значительную часть языковых возможностей.

Линковщик (linker) объединяет объектные файлы, библиотеки и рантайм в единый исполняемый файл или библиотеку. В зависимости от вида подключаемых библиотек линковаться с ними можно статически или динамически.

Статическая линковка означает полное включение библиотеки в результирующий бинарный файл. При статической линковке на момент сборки есть вся необходимая информация, чтобы разрешить межфайловые зависимости. Динамическая линковка подразумевает подгрузку используемой библиотеки каждый раз при запуске программы. Поэтому даже если сборка программы прошла успешно, необходимо, чтобы на целевой машине была установлена нужная библиотека. Все библиотеки проверяются на совместимость по ABI, но об этом чуть позже.

Именно на этапе линковки выявляются нарушения ODR между несколькими единицами трансляции и нарушения межфайловых зависимостей.

Линковщик заменяет вызовы функций по имени из других объектных файлов и библиотек на вызовы по адресу. Если целью сборки является исполняемый файл, то линковщик подключает код, выполняющийся с момента запуска программы и до входа в функцию `main()`.

На этапе линковки возможны [некоторые оптимизации](https://johnnysswlab.com/link-time-optimizations-new-way-to-do-compiler-optimizations/) (LTO, link time optimizations), в том числе встраивание функций (inlining), объявление которых расположено в другом объектном файле.

В этом коде допущена ошибка, выявляемая на этапе линковке. Исправьте ее. {.task_text}

```c++ {.task_source #cpp_chapter_0040_task_0030}
#include <iostream>

int Main()
{
    std::cout << "Java style!" << std::endl;
    return 0;
}
```
Линковщик не может найти функцию `main()`. {.task_hint}
```c++ {.task_answer}
#include <iostream>

int main()
{
    std::cout << "Java style!" << std::endl;
    return 0;
}
```

Вернемся к проекту gcd в последний раз. Вызовем `g++` для **сборки исполняемого файла** и запустим его. По умолчанию g++ сохраняет бинарный файл с именем a.out (assembler output). Опция `-o` дает файлу другое имя:

```
g++ main.cpp -o gcd
./gcd
```
```
21
```

Итак, на входе этапа линковки — набор объектных файлов, а на выходе — исполняемый файл или библиотека. Чтобы нагляднее продемонстрировать линковку и предшествующие ей стадии, возьмем более сложный проект, чем gcd.

Допустим, проект поискового движка search_engine содержит два файла реализации и три хедера. Он собирается в исполняемый файл. Для этого препроцессор из файлов реализации получает единицы трансляции, компилятор транслирует их в код на ассемблере, ассемблер получает его и создает объектные файлы, а линковщик объединяет их в исполняемый файл.

![Прохождение файлами пайплайна сборки](https://raw.githubusercontent.com/senjun-team/senjun-courses/introduce-cpp/illustrations/cpp/cpp_build_pipeline_files.jpg) {.illustration}

## C++ ABI

[ABI](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9) (application binary interface) — интерфейс между бинарными модулями. Например, между библиотекой и подключающей ее программой. 

В мире C и C++ ABI фиксирует подробности реализации языка. Например, стандарт C++ описывает синтаксис функций, но не указывает, как в функцию передаются параметры — в регистрах процессора, по стеку или комбинированно. Этим заведует ABI. Стандарт C++ определяет, что такое классы и как их использовать. ABI определяет, как хранятся поля класса в памяти компьютера: их расположение, порядок, [выравнивание.](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

Стандарт языка разрабатывается комитетом по стандартизации, а ABI — вендорами компиляторов.

Совместимость по ABI важна и для статических, и для динамических библиотек. Если два компилятора на одной и той же платформе будут следовать разным ABI, то собранный этими компиляторами код не удастся слинковать. Кстати, между GCC и Clang [нет](https://libcxx.llvm.org/) полной совместимости по ABI. Код, собранный разными версиями одного и того же компилятора, тоже может быть не совместим по ABI.

## Библиотеки

Библиотеки C++ бывают трех видов:
- Статические (archive, архив).
- Динамические (shared library, разделяемая библиотека).
- Header-only (состоящие только из заголовочных файлов).

У любой библиотеки есть хедеры. Они содержат интерфейс библиотеки — объявления функций и других сущностей. По месту их использования требуется подключать соответствующие им хедеры.

### Статические библиотеки

Статические библиотеки имеют расширение `.a` под *nix и `.lib` под Windows. На этапе линковки они становятся частью бинаря, который их использует. Это увеличивает размер программы, но не создает внешних зависимостей. Такие библиотеки иногда называют архивами, потому что они представляют из себя несколько объектных файлов, скомпонованных вместе.

Соберем статическую библиотеку. Для этого заведем проект gcd_lib, состоящий из двух файлов: gcd.h и gcd.cpp.

Хедер gcd.h содержит объявление функции `gcd()`:

```c++
#pragma once

int gcd(int a, int b);
```

А файл реализации gcd.cpp содержит ее определение:

```c++
#include "gcd.h"

int gcd(int a, int b) 
{
    while (b != 0) 
    {
        if (a > b)
            a = a - b;
        else
            b = b - a;
    }

    return a;
}
```

Чтобы собрать этот проект в статическую библиотеку, нужно сначала получить объектный файл, а затем вызывать команду [ar](https://linux.die.net/man/1/ar) (archive) с опциями `rvs`. Она упакует объектный файл в архив. Опция `r` (replace) означает замену или добавление файлов в архив; `v` (verbose) — подробный вывод в процссе выполнения команды, `s` — создание в архиве индекса для ускорения поиска символов (symbol lookup) во время линковки с библиотекой.

```shell
g++ -c -o gcd.o gcd.cpp
ar rvs libgcd.a gcd.o
```
```
ar: creating libgcd.a
a - gcd.o
```

### Динамические библиотеки

Динамические библиотеки имеют расширение `.so` (shared object) под *nix и `.dll` (dynamic link library) под Windows. Они не становятся частью программы, а подгружаются во время исполнения. Несколько исполняемых файлов совместно могут использовать один и тот же файл библиотеки. Поэтому динамические библиотеки и называют разделяемыми. Такой подход экономит место, но требует установки на целевую систему библиотеки нужной версии.

Чтобы скомпилировать проект gcd_lib в динамическую библиотеку, нужно создать объектный файл, а затем с помощью опции `-shared` собрать из него библиотеку:

```shell
g++ -c -o gcd.o gcd.cpp
g++ -shared -o libgcd.so gcd.o
ls
```
```
gcd.cpp  gcd.h  gcd.o  libgcd.so
```

### Header-only библиотеки

Header-only библиотеки состоят _только_ из заголовочных файлов. Их удобно подключать к проекту, ведь дополнительной линковки с такой библиотекой не требуется. Код header-only библиотеки копируется препроцессором в файлы реализации проекта по месту директивы `#include`.

## Рантайм C++

В языках семейства C есть **рантайм** — набор библиотек, реализующих часть описанных в стандарте языка возможностей, его [модель исполнения](https://en.wikipedia.org/wiki/Execution_model) и функции для корректного запуска программы. Рантайм C++ помимо прочего реализует механизм обработки исключений, операторы `new` и `delete` для выделения и освобождения памяти, а также нешаблонный код стандартной библиотеки.

Не путайте концепцию рантайма в C и C++ с рантаймом в [управляемых языках,](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_%D1%81%D1%80%D0%B5%D0%B4%D1%8B_%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F) таких как Java, C# и python. В них рантайм — это полноценная среда выполнения программы, укомплектованная сборщиком мусора и виртуальной машиной.

Программы на C++ линкуются не только с рантаймом C++, но и с рантаймом C. Зачем? Дело в том, что рантайм C++ опирается на рантайм C. Например, операторы `new` и `delete` в C++ зачастую реализованы через сишные функции `malloc` и `free`.

С рантаймом можно линковаться динамически и статически. По умолчанию линковка динамическая. С рантаймом можно не линковаться вовсе. Тогда в программе будет доступно минимальное подмножество языка. Это имеет смысл при разработке [встраиваемых систем](https://ru.wikipedia.org/wiki/%D0%92%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0) (embedded systems), драйверов и низкоуровневых программ, запускаемых на устройствах без ОС.

Библиотека с рантаймом C++ от GCC называется libstdc++, а от Clang — libc++. Библиотека glibc (GNU C Library) реализует рантайм C. При линковке рантайма, как и при линковке любой другой библиотеки, встает необходимость совместимости по ABI. Если в программе подключено две библиотеки, использующие несовместимые между собой версии рантайма, то компиляция завершится с ошибкой.

Помимо рантайма языка есть еще **рантайм компилятора.** Он содержит определения функций, неявно используемые компилятором для поддержки операций, которых нет на целевой машине. Например, операции над 64-битными числами на 32-битных архитектурах.

Программа собрана компилятором GCC с опциями по умолчанию. Можно ли ее запустить на такой же платформе, но с рантаймом от Clang? `y/n`  {.task_text}

```consoleoutput {.task_source #cpp_chapter_0040_task_0040}
```
У рантайма GCC и Clang нет полной совместимости по ABI. {.task_hint}
```cpp {.task_answer}
n
```

Реализация рантайма зависит от компилятора, его версии, от целевой системы и архитектуры процессора. 

Давайте посмотрим, какие библиотеки подгружает наш бинарь gcd. Он собран компилятором g++ 14.2.0 под дистрибутивом Linux OpenSuse. Запустим его из-под [strace](https://man7.org/linux/man-pages/man1/strace.1.html) — команды, отслеживающей, какие системные вызовы делает программа. Опция `-e trace=openat` означает, что интересуют только вызовы [openat](https://linux.die.net/man/2/openat) для открытия файловых дескрипторов.

```shell
strace -e trace=openat ./gcd
```
```
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib64/libstdc++.so.6", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib64/libm.so.6", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib64/libgcc_s.so.1", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib64/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
hello GCC!
+++ exited with 0 +++
```

Простой бинарь, выводящий в консоль "hello GCC!", зависит от пяти динамических библиотек! Воспроизведите этот эксперимент у себя и сравните результаты.

Кратко перечислим, какие библиотеки используются в данном конкретном случае.

Библиотека [ld.so](https://www.opennet.ru/man.shtml?topic=ld.so&category=8&russian=0) входит в пакет glibc, то есть является частью рантайма C. Она ищет и подгружает используемые в программе динамические библиотеки, подготавливает программу к запуску и отвечает за запуск. В ней содержится код, инициализирующий глобальные переменные и вызывающий функцию `main()` — точку входа в программу.

Библиотека [libm.so](https://packages.debian.org/search?searchon=contents&keywords=libm.so&mode=path&suite=stable&arch=any) тоже входит в пакет glibc и отвечает за реализацию математических функций из хедера `math.h`. Она была вынесена в отдельный файл по историческим причинам.

А [libc.so](https://www.man7.org/linux/man-pages/man7/libc.7.html) — это реализация стандартной библиотеки C. Также входит в пакет glibc.

Библиотека [libstdc++](https://packages.debian.org/ru/sid/libstdc++6) — это стандартная библиотека C++ из пакета libstdc++.

Библиотека [libgcc_s](https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html) — это рантайм компилятора GCC. Clang вместо нее может использовать библиотеку рантайма от LLVM под названием [compiler-rt,](https://clang.llvm.org/docs/Toolchain.html#compiler-rt-llvm) но из-за широкой распространенности тулчейна GNU компилятор Clang по умолчанию использует libgcc_s.

## Автоматизация сборки

Если проект содержит больше одного-двух файлов, то собирать его прямым вызовом драйвера компилятора становится неудобно. К сожалению, за свою 40-летнюю историю С++ так и не обзавелся стандартной **системой сборки.** Однако среди многообразия существующих инструментов де-факто лидирует CMake. Нередко он используется в связке с Make.

### Make

[Make](https://www.gnu.org/software/make/) — это очень старая консольная утилита, команды для которой описываются в специальных конфигурационных файлах Makefile. В них на скриптовом языке задаются зависимости между файлами проекта и правила для их удовлетворения. Канонически Make используется для автоматизации сборки пакетов, их установки и удаления. Но теоретически он приспосабливается под автоматизацию чего угодно, ведь из Makefile можно вызывать любые консольные команды.

Makefile для сборки проекта gcd выглядит так:

```
gcd: main.cpp
	g++ main.cpp -o gcd
```

Здесь `gcd` в первой строке — цель (имя цепочки действий); main.cpp — условия для ее успешного достижения. Затем перечислены команды, которые требуется выполнить.

Чтобы собрать проект с помощью этого Makefile, запускается команда make с указанием цели:

```shell
make gcd
```
```
g++ main.cpp -o gcd
```

Make все еще распространен благодаря огромному количеству легаси-проектов на C и C++. Например, он [собирает](https://github.com/torvalds/linux/blob/master/Makefile) ядро Linux. Подключать его в чистом виде к новым проектам не рекомендуется. Зато поверх Make работают несколько более дружелюбных и современных инструментов. В том числе CMake.

### CMake

[CMake](https://cmake.org/) (Cross-platform Make) — система для автоматизации компиляции, пакетирования и установки. CMake не занимается сборкой напрямую. Вместо этого он генерирует файлы сборки для другого инструмента и вызывает его. CMake умеет работать поверх таких систем как [Make,](https://www.gnu.org/software/make/) [Ninja,](https://ninja-build.org/) [Microsoft Visual Studio,](https://learn.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-170) [Apple Xcode.](https://cmake.org/cmake/help/latest/generator/Xcode.html)

CMake решает две основные задачи:
- Упрощение управления проектом по сравнению с Make и [GNU Autotools.](https://ru.wikipedia.org/wiki/Autotools)
- Кроссплатформенная сборка в отличие от проприетарных Microsoft Visual Studio и Apple Xcode.

CMake читает файлы конфигурации CMakeLists.txt, в которых перечисляются команды на макроязыке CMake. Для проекта gcd файл CMakeLists.txt выглядит так:

```
cmake_minimum_required(VERSION 3.12)
project(CMake_Demo)

set(CMAKE_CXX_STANDARD 23)

add_executable(gcd main.cpp)
```

Чтобы собрать проект, команду `cmake` требуется вызвать дважды с разными опциями. Сначала для создания файлов сборки, затем — для самой сборки.

Файлы сборочной системы и артефакты сборки принято хранить в отдельной директории, чтобы не замусоривать проект. Выполним создание файлов сборки в директории build. Для этого воспользуемся опцией `-B build/`.

```shell
cmake -B build/
```
```
-- The C compiler identification is GNU 14.2.0
-- The CXX compiler identification is GNU 14.2.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done (0.4s)
-- Generating done (0.0s)
-- Build files have been written to: /home/code_runner/project/build
```

Когда файлы сборки готовы, можно собрать бинарь проекта. Он тоже сохранится в директории build:

```shell
cmake --build build/
```
```
[ 50%] Building CXX object CMakeFiles/main.dir/main.cpp.o
[100%] Linking CXX executable gcd
[100%] Built target gcd
```

За пару десятилетий эволюции проекта CMake его макроязык адаптировался под нужды индустрии. По аналогии с термином «Modern C++» в обиход вошел термин [«Modern CMake».](https://cliutils.gitlab.io/modern-cmake/README.html) Он относится к CMake версии 3.15 и выше, начиная с которой файлы CMakeLists.txt становятся более удобными и читабельными. Несмотря на этот положительный тренд, у CMake есть конкуренты:
- [SCons](https://scons.org/) — самодостаточная система cборки, написанная на Python.
- [Gradle](https://docs.gradle.org/current/userguide/building_cpp_projects.html) — выходец из мира Java, работает поверх JVM.
- [Meson](https://mesonbuild.com/) — как и CMake, не занимается сборкой напрямую. Вместо Make по умолчанию использует [Ninja.](https://ninja-build.org/)
- [Basel](https://bazel.build/start/cpp) — мультиязычная система сборки от Google.

Различные варианты CMakeLists.txt любопытно поизучать в таких проектах как [GoogleTest,](https://github.com/google/googletest) [Boost](https://github.com/boostorg/boost) и [Nlohmann Json.](https://github.com/nlohmann/json)

### Пакетные менеджеры

Почти всегда в коммерческой разработке требуется автоматизация не только сборки, но и сопутствующих ей процессов:
- разрешения зависимостей проекта,
- версионирования,
- пакетирования,
- доставки пакета в репозиторий.

Эти задачи решают пакетные менеджеры. В мире C++ два самых распространенных пакетных менеджера — это [Conan](https://docs.conan.io/2/tutorial.html) и [vcpkg.](https://learn.microsoft.com/en-us/vcpkg/) Оба легко встраиваются в CI/CD, оба умеют работать в связке с популярными системами автоматизации сборки.

Можно ли жить без пакетных менеджеров? Вполне, хоть это и менее удобно. В таком случае разрешение зависимостей чаще всего организуется с помощью [git-сабмодулей](https://git-scm.com/book/en/v2/Git-Tools-Submodules) либо управления внешним проектом через функционал [ExternalProject](https://cmake.org/cmake/help/latest/module/ExternalProject.html) в CMake. Пакетирование же осуществляется стандартными средствами для создания rpm или deb пакетов. А версионирование и заливка пакета в репозиторий организуются средствами CI/CD.

-----

## Резюме
- Драйвер компилятора — это фасад для вызова препроцессора, компилятора, ассемблера и линковщика. Почти всегда драйвер компилятора называют просто компилятором.
- Единица трансляции — это обработанный препроцессором файл реализации.
- Препроцессор переписывает код в файлах реализации и сохраняет результат в единицы трансляции.
- Компилятор из единиц трансляции генерирует код на ассемблере.
- AST — абстрактное синтаксическое дерево, используемое компилятором для промежуточного представления кода.
- Ассемблер создает объектные файлы, по одному на единицу трансляции.
- Объектный файл — бинарный файл, полученный в результате обработки компилятором и ассемблером единицы трансляции.
- Линковщик объединяет объектные файлы друг с другом, с используемыми библиотеками и рантаймом. Он создает исполняемый файл или библиотеку.
- Статические библиотеки на этапе линковки становятся частью бинаря.
- Динамические библиотеки подгружаются в память в момент запуска бинаря.
- ABI (Application Binary Interface) — интерфейс между бинарными модулями, фиксирующий детали реализации языка.
- В мире C и C++ рантайм — это набор библиотек, реализующих часть описанных в стандарте языка возможностей, его модель исполнения и функции для запуска программы.