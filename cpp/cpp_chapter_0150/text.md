# Глава 15. Ссылки и указатели

## Ссылки

Вы уже [знаете,](/courses/cpp/chapters/cpp_chapter_0141/#block-alias) что в C++ для любого типа можно завести псевдоним. То есть определить новое имя и работать с ним вместо исходного типа. Точно так же можно поступить и с переменной: создать альтернативное имя и обращаться к ней через него. **Ссылка** (reference) — это и есть псевдоним для существующей переменной.

Чтобы объявить ссылку, между типом и именем переменной ставится символ амперсанда `&`:

```cpp
char c = 'A';
char & c_ref = c;  // Ссылка

std::println("{}", c_ref);
```
```
A
```

Амперсанд после типа означает, что перед вами не обычный тип, а ссылочный. В данном примере у переменной `c_ref` тип `char &`: это ссылка на переменную `char`.

![Ссылки](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-142/illustrations/cpp/references.jpg) {.illustration}

Читать и изменять значение можно как через исходную переменную, так и через ссылку:

```cpp
std::size_t count = 1;
std::size_t & n = count;
std::println("count={} n={}", count, n);

++n;
std::println("count={} n={}", count, n);

count += 2;
std::println("count={} n={}", count, n);
```
```
count=1 n=1
count=2 n=2
count=4 n=4
```

Что выведется в консоль? {.task_text}

```cpp {.example_for_playground .example_for_playground_008}
unsigned char x = 255;
unsigned char & ref1 = x;
unsigned char & ref2 = x;

++ref1;
++ref2;

std::println("{} {} {}", x, ref1, ref2);
```

```consoleoutput {.task_source #cpp_chapter_0150_task_0010}
```
. {.task_hint}
```cpp {.task_answer}
cba
```

Расстановка пробелов вокруг `&` при объявлении ссылки роли не играет. Допустимы и такие варианты:

```cpp
std::size_t& n = count;
std::size_t &n = count;
```

В момент создания ссылки ее необходимо инициализировать. Не инициализированная ссылка приведет к ошибке компиляции:

```cpp
import std;

int main()
{
    std::string & s;
}
```
```
main.cpp:5:19: error: declaration of reference variable 's' requires an initializer
    5 |     std::string & s;
      |                   ^
```

### Передача параметров в функцию по ссылке

По умолчанию функции принимают параметры по значению (by value): при вызове функции в нее вместо исходных переменных попадают _копии._ Убедимся в этом:

```cpp
import std;

void sort(std::vector<int> v)
{
    std::sort(v.begin(), v.end());
    std::println("Inside function: {}", v);
}

int main()
{
    std::vector data{5, 0, -1, 2};

    std::println("Before calling sort(): {}", data);
    sort(data);
    std::println("After calling sort(): {}", data);
}
```
```
Before calling sort(): [5, 0, -1, 2]
Inside function: [-1, 0, 2, 5]
After calling sort(): [5, 0, -1, 2]
```

Копирование — это дорогая операция, особенно для тяжелых объектов. Представьте, что в этом примере в функцию `sort()` передается массив из миллионов элементов. Компилятор скопирует их все! Так вот, предотвращение лишнего копирования объектов — это наиболее частый сценарий использования ссылок.

Так заменим же передачу вектора по значению на передачу по ссылке (by reference). Для этого между типом и именем параметра функции добавим амперсанд:

```cpp
void sort(std::vector<int> & v);
```

Когда функция принимает аргумент по ссылке, компилятор связывает существующую переменную с новым именем — параметром функции. То есть заводит для нее псевдоним. И функция получает доступ к исходному объекту вместо копии:

```cpp
import std;

void sort(std::vector<int> & v) // передаем v по ссылке
{
    std::sort(v.begin(), v.end());
    std::println("Inside function: {}", v);
}

int main()
{
    std::vector data{5, 0, -1, 2};

    std::println("Before calling sort(): {}", data);
    sort(data);
    std::println("After calling sort(): {}", data);
}
```
```
Before calling sort(): [5, 0, -1, 2]
Inside function: [-1, 0, 2, 5]
After calling sort(): [-1, 0, 2, 5]
```

Реализуйте функцию `rotate_clockwise()`, которая принимает по ссылке квадратную матрицу `m`. Матрица — это вектор векторов с элементами типа `short`. {.task_text}

Функция поворачивает исходную матрицу на 90 градусов по часовой стрелке и ничего не возвращает. В подсказке описан простой вариант реализации. {.task_text}

Например, матрица `{{1, 2}, {3, 4}}` после вызова функции превратится в `{{3, 1}, {4, 2}}`: {.task_text}

```
// Исходная матрица
[
    [1, 2]
    [3, 4]
]

// Поворот на 90 градусов по часовой стрелке
[
    [3, 1]
    [4, 2]
]
```

```cpp {.task_source #cpp_chapter_0142_task_0020}
// Ваша реализация rotate_clockwise()

```
Сначала поменяйте местами все элементы `m[i][j]` и `m[j][i]`. Это транспонирует матрицу, то есть превратит строки в столбцы, а столбцы — в строки. Затем инвертируйте порядок элементов в каждом ряду. {.task_hint}
```cpp {.task_answer}

```

## Ссылки и константность

Зачастую требуется ограничить доступ к объекту по ссылке. Чтобы через нее можно было только читать, но не изменять значение. Именно эту задачу решают константные ссылки. 

Чтобы сделать ссылку константной, к ее типу добавляется квалификатор `const`:

```cpp
int val = 16;
const int & ref = val;

++val; // ок
++ref; // ошибка
```
```
main.cpp:9:1: error: cannot assign to variable 'ref' with const-qualified type 'const int &'
    9 | ++ref;
      | ^ ~~~
```

Например, функция `is_localhost()` принимает по ссылке объект `ip` и читает его поля:

```cpp
bool is_localhost(IpAddr & ip);
```



Реализуйте функцию `swap()`, которая принимает два параметра типа `int` и меняет их значения местами. {.task_text}

Например, есть две переменные `x = 1` и `y = 5`. После вызова `swap(x, y)` в `x` должно лежать число `5`, а в `y` — `1`. {.task_text}

```cpp {.task_source #cpp_chapter_0142_task_0030}

```
Функция должна принимать два параметра по ссылке. Чтобы поменять их местами, внутри функции вы можете завести дополнительную переменную. {.task_hint}
```cpp {.task_answer}

```

## Указатели

Указатель (pointer) — это переменная, которая хранит адрес в оперативной памяти. Отсюда и название: значение переменной как бы _указывает_ на некую область памяти. А адрес — это по сути число. Например, `0x55ae9a41c2a0`. Поэтому можно сказать, что указатель — это переменная, в которой лежит целое положительное число, воспринимаемое компилятором как адрес.


```cpp
std::size_t count = 1;
std::size_t * n = count; // Указатель
std::println("count={} n={}", count, n);

++n;
std::println("count={} n={}", count, n);

count += 2;
std::println("count={} n={}", count, n);
```
```
count=1 n=1
count=2 n=2
count=4 n=4
```

![Указатели](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-142/illustrations/cpp/pointers.jpg) {.illustration}



Если на данный момент указатель не указывает ни какую область памяти, ему нужно присвоить специальное значение `std::nullptr`. 















Кстати, в предыдущих главах вы уже [решали](/courses/cpp/chapters/cpp_chapter_0050/#block-predicate) задачи, в которых требовалось одну функцию передать в другую. Вы реализовывали это с помощью шаблонов:

```cpp
import std;

template<class Fn>
bool str_none_of(std::string s, Fn pred) // pred - это функция
{
    for (char c: s)
    {
        if (pred(c))
            return false;
    }

    return true;
}

bool is_a(char c)
{
    return c == 'a';
}

int main()
{
    std::println("str_none_of(\"generic\", is_a) = {}", str_none_of("generic", is_a));
}
```

В этом примере функция `str_none_of()` принимает шаблонный параметр `pred` и вызывает его внутри как функцию. Внутри `main()` в качестве аргумента `str_none_of()` передается функция `is_a()`. В процессе сборки этого кода компилятор находит вызов шаблонной функции и анализирует переданный набор аргументов. Для этого набора он _инстанцирует_ шаблон: порождает обычную функцию из шаблона функции `str_none_of()`. Так вот эта обычная функция принимает указатель на функцию, тип которой совпадает с типом `is_a()`.