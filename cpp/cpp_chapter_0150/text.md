# Глава 15. Ссылки

Вы уже [знаете,](/courses/cpp/chapters/cpp_chapter_0141/#block-alias) что в C++ для любого типа можно завести псевдоним. То есть определить новое имя и работать с ним вместо исходного типа. Точно так же можно поступить и с переменной: создать альтернативное имя и обращаться к ней через него. **Ссылка** (reference) — это и есть псевдоним для существующей переменной.

Чтобы объявить ссылку, между типом и именем переменной ставится символ амперсанда `&`. Он называется оператором ссылки (referece operator).

```cpp
char c = 'A';
char & c_ref = c;  // Ссылка

std::println("{}", c_ref);
```
```
A
```

Амперсанд после типа означает, что перед вами не обычный тип, а ссылочный. В данном примере у переменной `c_ref` тип `char &`: это ссылка на переменную `char`.

![Ссылки](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-142/illustrations/cpp/references.jpg) {.illustration}

Читать и изменять значение можно как через исходную переменную, так и через ссылку:

```cpp
std::size_t count = 1;
std::size_t & n = count;
std::println("count={} n={}", count, n);

++n;
std::println("count={} n={}", count, n);

count += 2;
std::println("count={} n={}", count, n);
```
```
count=1 n=1
count=2 n=2
count=4 n=4
```

Что выведется в консоль? {.task_text}

```cpp {.example_for_playground .example_for_playground_008}
unsigned char x = 255;
unsigned char & ref1 = x;
unsigned char & ref2 = x;

++ref1;
++ref2;

std::println("{} {} {}", x, ref1, ref2);
```

```consoleoutput {.task_source #cpp_chapter_0150_task_0010}
```
. {.task_hint}
```cpp {.task_answer}
cba
```

Расстановка пробелов вокруг `&` при объявлении ссылки роли не играет. Допустимы и такие варианты:

```cpp
T& name
```

```cpp
T &name
```

## Основные правила для работы со ссылками

Тип ссылки обязан совпадать с типом переменной, на которую она ссылается. Нарушение этого правила приведет к ошибке компиляции:

```cpp
bool has_access = false;
    
std::string & ref = has_access;
```
```
main.cpp:7:19: error: non-const lvalue reference to type 'std::string' (aka 'basic_string<char>') cannot bind to a value of unrelated type 'bool'
    7 |     std::string & ref = has_access;
      |                   ^     ~~~~~~~~~~
```

В момент создания ссылки ее необходимо инициализировать. Не инициализированная ссылка приведет к ошибке компиляции:

```cpp
import std;

int main()
{
    std::string & s;
}
```
```
main.cpp:5:19: error: declaration of reference variable 's' requires an initializer
    5 |     std::string & s;
      |                   ^
```

И, наконец, ссылку нельзя переназначить. Ссылка инициализируется в момент своего объявления. После этого применение к ней оператора `=` будет означать присваивание значения той переменной, на которую указывает ссылка. Иными словами, все свое время жизни ссылка «смотрит» на один и тот же объект.

Что выведется в консоль? {.task_text}

```cpp {.example_for_playground}
int a = 1;
int b = 5;

int & ref = a;
ref = b;
b = 8;

std::println("{} {} {}", a, ref, b);
```

```consoleoutput {.task_source #cpp_chapter_0150_task_0020}
```
. {.task_hint}
```cpp {.task_answer}
5 5 8
```

## Передача параметров в функцию по ссылке

По умолчанию функции принимают параметры по значению (by value): при вызове функции в нее вместо исходных переменных попадают _копии._ Убедимся в этом:

```cpp
import std;

void sort(std::vector<int> v)
{
    std::sort(v.begin(), v.end());
    std::println("Inside function: {}", v);
}

int main()
{
    std::vector data{5, 0, -1, 2};

    std::println("Before calling sort(): {}", data);
    sort(data);
    std::println("After calling sort(): {}", data);
}
```
```
Before calling sort(): [5, 0, -1, 2]
Inside function: [-1, 0, 2, 5]
After calling sort(): [5, 0, -1, 2]
```

Копирование — это дорогая операция, особенно для тяжелых объектов. Представьте, что в этом примере в функцию `sort()` передается массив из миллионов элементов. Компилятор скопирует их все! Так вот, предотвращение лишнего копирования — это наиболее частый сценарий использования ссылок.

Так заменим же передачу вектора по значению на передачу по ссылке (by reference). Для этого между типом и именем параметра функции добавим амперсанд:

```cpp
void sort(std::vector<int> & v);
```

Когда функция принимает аргумент по ссылке, компилятор связывает существующую переменную с новым именем — параметром функции. То есть заводит для нее псевдоним. И функция получает доступ к исходному объекту вместо копии:

```cpp
import std;

void sort(std::vector<int> & v) // передаем v по ссылке
{
    std::sort(v.begin(), v.end());
    std::println("Inside function: {}", v);
}

int main()
{
    std::vector data{5, 0, -1, 2};

    std::println("Before calling sort(): {}", data);
    sort(data);
    std::println("After calling sort(): {}", data);
}
```
```
Before calling sort(): [5, 0, -1, 2]
Inside function: [-1, 0, 2, 5]
After calling sort(): [-1, 0, 2, 5]
```

Реализуйте функцию `rotate_clockwise()`, которая принимает по ссылке квадратную матрицу `m` и ничего не возвращает. Матрица — это вектор векторов с элементами типа `short`. {.task_text}

Функция поворачивает исходную матрицу на 90 градусов по часовой стрелке. В подсказке описан простой вариант реализации поворота. {.task_text}

Например, матрица `{{1, 2}, {3, 4}}` после вызова функции превратится в `{{3, 1}, {4, 2}}`: {.task_text}

```
// Исходная матрица
[
    [1, 2]
    [3, 4]
]

// Поворот на 90 градусов по часовой стрелке
[
    [3, 1]
    [4, 2]
]
```

```cpp {.task_source #cpp_chapter_0142_task_0030}
// Ваша реализация rotate_clockwise()

```
Сначала поменяйте местами все элементы `m[i][j]` и `m[j][i]`. Это транспонирует матрицу, то есть превратит строки в столбцы, а столбцы — в строки. Затем инвертируйте порядок элементов в каждом ряду. {.task_hint}
```cpp {.task_answer}

```

В стандартной библиотеке есть функция [std::swap()](https://en.cppreference.com/w/cpp/algorithm/swap.html), которая принимает два параметра и меняет местами их значения. Разумеется, для этого она принимает оба параметра по ссылке. Так выглядит ее объявление:

```cpp
template<class T>
void swap(T & a, T & b);
```

Реализуйте свою функцию `swap()`. Она принимает два параметра типа `int` и меняет их местами. {.task_text}

Например, есть две переменные `x = 1` и `y = 5`. После вызова `swap(x, y)` в `x` должно лежать число `5`, а в `y` — `1`. {.task_text}

```cpp {.task_source #cpp_chapter_0142_task_0040}

```
Функция должна принимать два параметра по ссылке. Чтобы поменять их местами, внутри функции вы можете завести дополнительную переменную. {.task_hint}
```cpp {.task_answer}

```

## Ссылки и константность

Зачастую требуется сделать так, чтобы через ссылку можно было только читать, но не изменять значение. Именно эту задачу решают константные ссылки. Их также называют ссылками на константные объекты. 

Чтобы сделать ссылку константной, к ее типу добавляется квалификатор `const`. Как и при объявлении любой переменной, тип и `const` могут идти в любом порядке:

```cpp
const T &
```

```cpp
T const &
```

В этом примере мы создаем константную ссылку, но пытаемся обратиться к ней на запись. Это приводит к ошибке компиляции:

```cpp
int val = 16;
const int & ref = val;
++val; // ок

std::println("{}", ref); // ок: обращение по ссылке на чтение
++ref;                   // ошибка: обращение на запись
```
```
main.cpp:12:5: error: cannot assign to variable 'ref' with const-qualified type 'const int &'
   12 |     ++ref;
      |     ^ ~~~
```

Константные ссылки активно используются в функциях, которые должны получить доступ к объекту только на чтение.

```cpp
bool is_localhost(const IpAddr & ip)
{
    // Только читаем поля объекта ip
}
```

Реализуйте функцию `most_common_word()`, которая принимает два параметра: строку `text` и неупорядоченное множество из строк `stop_words`. Оба параметра передаются по константной ссылке. {.task_text}

Функция должна вернуть слово, встречающееся в `text` чаще всего и не входящее в `stop_words`. Строка `text` состоит из слов, разделенных пробелами. {.task_text}

Например, для `text="a bb a bb"` и `stop_words={"a", "c"}` функция должна вернуть строку `"bb"`. {.task_text}

```cpp {.task_source #cpp_chapter_0142_task_0050}
// Ваша реализация most_common_word()
```
. {.task_hint}
```cpp {.task_answer}

```

## Висячие ссылки


## Возврат значения из функции по ссылке

Функция может не только принимать параметры по ссылке, но и возвращать объект по ссылке. Для этого тип возвращаемого значения помечается как ссылочный:

```cpp
T & func_name(params)
{
    // ...
}
```



## Когда нужно и не нужно использовать ссылки

----------

## Резюме

- Ссылка (reference) — это псевдоним для уже существующей переменной.
- Если функция принимает параметр по значению, то при каждом ее вызове происходит копирование соответствующего аргумента. Если функция принимает параметр по ссылке, копирования не происходит. Функция работает с исходным объектом.
- Константная ссылка и ссылка на константный объект — это одно и то же. Это ссылка, по которой можно только читать, но не изменять объект.
