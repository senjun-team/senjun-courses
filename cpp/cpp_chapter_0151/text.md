# Глава 15.1. Зачем нужна эта боль

C++ — это высокоуровневый язык с низкоуровневыми возможностями. С одной стороны, в нем есть средства для построения абстракций. В первую очередь это классы и шаблоны. С другой стороны, вы можете спуститься на уровень, максимально приближенный к аппаратному. C++ позволяет работать с памятью напрямую: вручную контролировать её выделение и освобождение, обращаться по конкретному адресу.

Управление памятью целиком завязано на концепцию указателей.

## Что такое указатель {#block-pointer-definition}

[Указатель](https://en.cppreference.com/w/cpp/language/pointer.html) (pointer) — это переменная, которая хранит адрес в оперативной памяти. Отсюда и название: значение такой переменной как бы _указывает_ на область памяти. А адрес — это по сути число. Например, `0x55ae9a41c2a0`. Поэтому можно сказать, что **указатель** — это переменная, в которой лежит целое неотрицательное число, трактуемое компилятором как адрес.

Если указатель содержит адрес конкретной переменной, то через него можно получить к ней доступ. Это _косвенный_ доступ: вместо прямого обращения к значению переменной сначала происходит обращение к указателю, а затем — к адресу, на который он указывает.

## Сырые указатели — неудобно и опасно

Работать с указателями _неудобно,_ и в следующей главе вы в этом убедитесь. Они напоминают ссылки с более архаичным, избыточным синтаксисом.

Через указатели работать с памятью на низком уровне, вручную следить за ее выделением и освобождением — тоже _очень неудобно._ К тому же и опасно. Чрезвычайно легко совершить ошибку:
- Выделить память и обратиться за ее пределы. Это UB.
- Выделить память и забыть ее освободить. Это приведет к утечке памяти.
- Освободить память, а потом обратиться по адресу этой памяти. Это приведет к UB, которое скорее всего будет выглядеть как повреждение памяти.
- Освободить выделенную память дважды. Это приведет к UB и наверняка к повреждению памяти.

Указатели — опасный инструмент. В современном C++ их нужно всеми силами [избегать.](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#rr-raii) Их называют сырыми указателями (raw pointers) из-за низкоуровневого доступа к адресам памяти и необходимости самостоятельно этой памятью управлять.

В стандартной библиотеке есть RAII-обертки над сырыми указателями. Их называют умными указателями (smart pointers), и вы должны выбирать их вместо сырых указателей. В момент инициализации умный указатель выделяет память, а при вызове деструктора — освобождает ее.

Так для чего в современном C++ нужны сырые указатели и зачем про них знать лично вам? 

## Указатели и динамическая память

Для начала [вспомним,](/courses/cpp/chapters/cpp_chapter_0090/#block-memory) где живут переменные.

![Упрощенное представление памяти процесса](https://raw.githubusercontent.com/senjun-team/senjun-courses/cpp-chapter-9/illustrations/cpp/process_memory.jpg) {.illustration}


Виртуальное адресное пространство процесса разбито на области. И переменные могут располагаться в одной из трех областей:
- **Статическая память** содержит переменные со статическим временем жизни. Это глобальные переменные и объекты, помеченные ключевым словом `static`.
- **Автоматическая память** (стек) хранит локальные переменные и аргументы функций. Их временем жизни управляет компилятор. С точки зрения разработчика оно регулируется автоматически. У каждого потока выполнения свой стек. Если вы собственноручно не запускали новые потоки, программа работает в 1 поток.
- **Динамическая память** (куча, heap) содержит переменные, память под которые выделяется вручную из кода программы. Происходит это во время исполнения, то есть динамически.

У статической и автоматической областей памяти крайне ограниченный размер. В зависимости от системы под статическую память процесса выделяется около 2 Кб, а под автоматическую — 1-8 Мб. У вас не получится завести там действительно большие объекты. Для них предназначена _динамическая память._

Как же работает заполнение стандартных контейнеров миллионами элементов? Когда внутри функции создается вектор, переменная типа `std::vector` размещается в автоматической памяти (на стеке). Но у вектора есть приватное поле — указатель на область в динамической памяти. Там и хранятся элементы. Объект вектора со всеми полями лежит на стеке, но одно из полей ссылается на динамическую память. И управление этой памятью реализовано в методах вектора.

Класс `std::vector` в этом плане не уникален. Вы найдёте указатели под капотом _всех_ контейнеров стандартной библиотеки. Без указателей не обойтись при реализации динамических структур данных, размер которых может меняться во время выполнения программы. Например, это списки, деревья и хеш-таблицы.

## Зачем уметь работать с указателями

Чем лучше вы разберетесь, как устроено управление динамической памятью, тем профессиональнее станет ваш код:
- Вы будете представлять, _что_ происходит внутри методов контейнеров. Следовательно, сможете избегать лишнего выделения или копирования памяти.
- Вы будете понимать, _почему_ у какого-то метода контейнера сложность — _амортизированная_ константа `O(1)`, а у другого — просто константа `O(1)`. А значит, вам проще будет писать эффективные алгоритмы.

Указатели — ключ к более глубокому пониманию языка и проведению оптимизаций потребления ресурсов и скорости выполнения. Поэтому, хоть в современном C++ не поощряется использование указателей, знать про них — **обязательно.** Уже не говоря о том, что указатели есть в кодовой базе практически любого более-менее долгоживущего проекта.

## План действий

В следующих главах мы пошагово разберем тему указателей:
- Для начала научимся с ними работать.
- Затем — перемещаться по памяти с помощью указателей.
- И, наконец, этой памятью управлять: выделять ее и освобождать.

Закрепим успех практикой по написанию простой версии контейнера а-ля `std::map`. После чего плавно переключимся на использование умных указателей.

## Резюме

- Указатель — это переменная, хранящая адрес в оперативной памяти.
- Переменная может располагаться в одной из трех областей памяти: в статической, автоматической, либо динамической памяти.
- Размер статической и автоматической памяти ограничен. Для работы с большим количеством объектов предназначена динамическая память.
- Работа с динамической памятью реализуется через указатели.
- В современном C++ использовать указатели не рекомендуется. Их также называют сырыми указателями.
- Предпочитайте им RAII-классы стандартной библиотеки под общим названием «умные указатели».
- Не смотря на это, указатели — одна из центральных концепций языка. И C++ разработчик обязан уметь ее применять.

