# Глава 15.1. Зачем нужна эта боль

C++ — это высокоуровневый язык с низкоуровневыми возможностями. С одной стороны, в нем есть средства для построения абстракций. В первую очередь это классы и шаблоны. С другой стороны, вы можете спуститься на уровень, максимально приближенный к аппаратному. C++ позволяет работать с памятью напрямую: вручную контролировать её выделение и освобождение, обращаться по конкретному адресу.

Управление памятью целиком завязано на концепцию указателей.

## Что такое указатель {#block-pointer-definition}

[Указатель](https://en.cppreference.com/w/cpp/language/pointer.html) (pointer) — это переменная, которая хранит адрес в оперативной памяти. Отсюда и название: значение такой переменной как бы _указывает_ на область памяти. А адрес — это по сути число. Например, `0x55ae9a41c2a0`. Поэтому можно сказать, что **указатель** — это переменная, в которой лежит целое неотрицательное число, трактуемое компилятором как адрес.

Если указатель содержит адрес конкретной переменной, то через него можно получить к ней доступ. Это _косвенный_ доступ: вместо прямого обращения к значению переменной сначала происходит обращение к указателю, а затем — к адресу, на который он указывает.

## Сырые указатели — неудобно и опасно

Работать с указателями _неудобно,_ и в следующей главе вы в этом убедитесь. Они напоминают ссылки с более архаичным, избыточным синтаксисом.

Через указатели работать с памятью на низком уровне — тоже неудобно и к тому же _опасно._ Чрезвычайно легко совершить ошибку:
- Выделить память и обратиться за ее пределы. Это UB.
- Выделить память и забыть ее освободить. Это приведет к утечке памяти.
- Освободить память, а потом обратиться по адресу этой памяти. Это приведет к UB, которое скорее всего закончится повреждением памяти.
- Освободить выделенную память дважды. Это приведет к UB и наверняка к повреждению памяти.

Указатели — опасный инструмент. Часто их называют **сырыми указателями** (raw pointers) из-за низкоуровневого доступа к адресам памяти и необходимости самостоятельно этой памятью управлять. В современном C++ их нужно всеми силами [избегать.](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#rr-raii) 

В стандартной библиотеке есть [RAII](/courses/cpp/chapters/cpp_chapter_0055/#block-raii)-обертки над сырыми указателями. Их называют **умными указателями** (smart pointers). В конструкторе умный указатель выделяет память, а в деструкторе — освобождает ее. В новом коде предпочтение отдается умным указателям.

Тогда чего ради лично вам разбираться с сырыми указателями?

## Указатели и динамическая память

Для начала [вспомним,](/courses/cpp/chapters/cpp_chapter_0090/#block-memory) где живут переменные.


![Упрощенное представление памяти процесса](https://raw.githubusercontent.com/senjun-team/senjun-courses/cpp-chapter-9/illustrations/cpp/process_memory.jpg) {.illustration}


Виртуальное адресное пространство процесса разбито на области. Переменные могут располагаться в одной из трех областей:
- статической,
- автоматической,
- динамической.


**Статическая память** содержит переменные со статическим временем жизни. Это глобальные переменные и объекты, помеченные ключевым словом `static`:

```cpp
int err_code = -1; // Глобальная переменная

int main()
{
    static int retries = 0; // Статическая переменная
}
```

Объем статической памяти определяется при компиляции программы. Он зависит от целевой платформы и по умолчанию довольно скромный: например, 2 Кб.

**Автоматическая память** (стек) хранит локальные переменные и аргументы функций. Их временем жизни управляет компилятор. С точки зрения разработчика оно регулируется автоматически.

```cpp
int run_proc(int pid)        // Параметр функции
{
    int err_code = run(pid); // Локальная переменная
    return err_code;
}
```

Максимальный размер стека ограничен. Он зависит от целевой платформы и опций компилятора. Как правило, под Linux по умолчанию действует ограничение в 8 Мб, а под Windows — 1 Мб. Фактический размер стека меняется по ходу выполнения программы: при вызове функции в стек добавляется новый стек-фрейм, при выходе из нее — удаляется.

Итак, у вас не получится завести в статической или автоматической памяти действительно много объектов. Также не выйдет вручную выделить там дополнительную память в рантайме. Обе эти проблемы решает _динамическая память._ 

**Динамическая память** (куча, heap) содержит переменные, память под которые выделяется _из кода программы._ Следовательно, происходит это во время исполнения, то есть динамически. Покажем это на примере контейнера `std::vector`, в котором вы можете создавать хоть десятки миллионов элементов.

Когда внутри функции создается вектор, переменная типа `std::vector` размещается в автоматической памяти (на стеке). Но у вектора есть приватное поле — _указатель_ на область в динамической памяти. Там и хранятся элементы. Объект вектора со всеми полями лежит на стеке, но одно из полей ссылается на динамическую память. И управление этой памятью реализовано в методах вектора.

Класс `std::vector` в этом плане не уникален. Вы найдёте указатели под капотом _всех_ контейнеров стандартной библиотеки. Без указателей не обойтись при реализации динамических структур данных, размер которых меняется в рантайме. Например, это списки, деревья и хеш-таблицы.

## Зачем уметь работать с указателями

Управление динамической памятью неотделимо от работы с указателями. Понимание, _что_ происходит c указателями и динамической памятью внутри классов стандартной библиотеки, поможет:
- Избегать лишнего выделения или копирования памяти.
- Понимать, _почему_ у какого-то метода контейнера сложность — _амортизированная_ константа `O(1)`, а у другого — просто константа `O(1)`. А значит, подбирать более эффективные алгоритмы.

Указатели — ключ к более глубокому пониманию языка, к оптимизации потребления ресурсов и скорости выполнения. Поэтому, хоть использование сырых указателей и не поощраяется, знать про них — **обязательно.** Уже не говоря о том, что указателями наводнен практически любой долгоживущий проект.

## План действий

В следующих главах мы пошагово разберем тему указателей:
- Для начала научимся с ними работать.
- Затем — перемещаться по памяти с помощью указателей.
- И, наконец, этой памятью управлять: выделять ее и освобождать.

Закрепим успех практикой по написанию простой версии контейнера а-ля `std::map`. После чего плавно переключимся на использование умных указателей.

----------

## Резюме

- Указатель — это переменная, хранящая адрес в оперативной памяти.
- Переменная может располагаться в одной из трех областей памяти: в статической, автоматической, либо динамической памяти.
- Размер статической и автоматической памяти ограничен. Для работы с большим количеством объектов предназначена динамическая память.
- Работа с динамической памятью организуется через указатели.
- В современном C++ использовать указатели не рекомендуется. Их также называют сырыми указателями.
- Предпочитайте им RAII-классы стандартной библиотеки под общим названием «умные указатели».
- Не смотря на это, указатели — одна из центральных концепций языка. И C++ разработчик обязан уметь ее применять.

