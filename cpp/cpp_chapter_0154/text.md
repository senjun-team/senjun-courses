# Глава 15.4. Динамическое выделение памяти

Временем жизни переменных в динамической памяти управляет разработчик. Оно _не заканчивается_ при выходе из области видимости. Поэтому выделение и освобождение памяти — всегда парные действия. Если вы выделили под объект память, то должны ее освободить, когда объект перестанет использоваться. Выделение динамической памяти называется **аллокацией.**

## Основной принцип управления памятью

Все конструкции для управления памятью **парные:** после выделения памяти ее нужно освободить. 

На одну аллокацию по указателю `p` должно приходиться ровно одно освобождение.
- Если вы забудете освободить память, то получите **утечку памяти.** Занятая область будет возвращена ОС только при завершении программы.
- Если освободите одну и ту же область дважды, то получите **двойное освобождение памяти.** Это повреждение памяти, приводящее к любым последствиям. Иными словами, типичное UB.

В C++ есть несколько способов для управления памятью. Перечислим их от низкоуровневых к высокоуровневым. Чем способ более высокоуровневый — тем он более предпочтительный.

## Низкий уровень на Си: malloc и free

Когда в 80-х годах C++ только начинал формироваться и назывался «Си с классами», важным для распространения языка было:
- Поддерживать полную совместимость с Си.
- Обеспечивать безболезненный переезд проектов с Си на «Си с классами».

За 40 лет мир изменился, и C++ давно [перестал быть](/courses/cpp/chapters/cpp_chapter_0012/#block-c-cpp) надстройкой над Си. Однако с тех времен осталось наследие: бесшовный вызов из C++ функций библиотеки [рантайма Си.](/courses/cpp/chapters/cpp_chapter_0112/#block-runtime) Для этого всего лишь нужно подключить сишный хедер:

```cpp
#include <stdlib.h>
```

В нем, помимо прочего, объявлены функции [malloc()](https://en.cppreference.com/w/cpp/memory/c/malloc.html) (memory allocation) и [free()](https://en.cppreference.com/w/cpp/memory/c/free.html) Это основные, но не единственные функции для управления памятью.

В `malloc()` передается количество байт для аллокации, функция выделяет память и возвращает на нее указатель `void *`:

```cpp
void * malloc(size_t size);
```

Что означает тип `void *`? Это **универсальный указатель:** он ссылается на область памяти с _любыми_ данными. То есть его тип данных не известен компилятору, и у вас не получится:
- Разыменовать указатель оператором `*` для доступа к данным.
- Применить к нему адресную арифметику.

Перед доступом к объекту указатель `void *` приводится к нужному типу. 

Если `malloc()` не удается выделить память, функция возвращает `NULL` (он же `nullptr`).

Функция `free()` освобождает память по указателю:

```cpp
void free(void * ptr);
```

Так выглядит вызов этих функций для аллокации и освобождение памяти под 10 объектов типа `int`:

```cpp
#include <stdlib.h>

int main()
{
    const std::size_t bytes =  10 * sizeof(int);
    int * p = static_cast<int *>(malloc(bytes));

    // Работаем с p

    free(p);
}
```

Вызов `malloc()` вернул указатель `void *`, и нам пришлось привести его к `int *` через `static_cast`. Когда память стала не нужна, мы освободили ее через `free()`.

[Пространства имен,](/courses/cpp/chapters/cpp_chapter_0053/) появившиеся еще на заре C++, позволяют предотвращать конфликты имен и удобно группировать код. Функции библиотеки рантайма Си были добавлены в пространство имен `std`. Для использования функций управления памятью необходимо подключить заголовок `cstdlib` или модуль `std`. Перепишем наш пример:

```cpp
#include <cstdlib> // cstdlib вместо stdlib.h

int main()
{
    const std::size_t bytes =  10 * sizeof(int);
    // Доступ через std::
    int * p = static_cast<int *>(std::malloc(bytes));

    // ...

    std::free(p);
}
```

Разницы между `malloc()` / `free()` и `std::malloc()` / `std::free()` нет. Просто второй вариант более идиоматичный для C++. Но оба варианта плохи. Их не рекомендуется использовать в современном C++ без явной необходимости. Вот основные причины:
- Эти функции нужны скорее для совместимости, чем для написания кода в новых проектах.
- Единственное, что делает `malloc()` — аллоцирует сырую память, в которой может находиться что угодно. Вы обязаны инициализировать ее вручную:
    - Для простых типов требуется инициализация.
    - Для других — ручной вызов конструктора.
- `malloc()` возвращает указатель `void *`, и вам нужно самостоятельно приводить его к указателю на нужный тип.

## Низкий уровень на C++: операторы new и delete

По принципу работы операторы [new](https://en.cppreference.com/w/cpp/memory/new/operator_new.html) и [delete](https://en.cppreference.com/w/cpp/memory/new/operator_delete.html) похожи на `malloc()` и `free()`, но у них есть перегрузки с дополнительными параметрами. Самая простая перегрузка `new` аллоцирует указанное количество байт и возвращает указатель `void *`. А оператор `delete` — освобождает эту память:

```cpp
void * operator new (std::size_t count);

void operator delete  (void * ptr);
```

```cpp
int * p = static_cast<int *>(new(10 * sizeof(int)));

// Работаем с p

delete p;
```

Под капотом эти операторы вызывают `malloc()` и `free()`. Зачем тогда они нужны? Это — более гибкий и идиоматичный для C++ способ управления памятью:
- Если `new` не может выделить память, то кидает исключение `std::bad_alloc`.
- Часть перегрузок `new` и `delete` разрешается _переопределять_ в своем коде.
- Есть множество перегрузок с дополнительными параметрами.
- `new` и `delete` ключевые слова C++ и его неотъемлемая часть. А `malloc()` и `free()` — функции на Си.

Оператор `new` обладает теми же серьезными недостатками, что и `malloc()`:
- Он выделяет память, но не умеет ее инициализировать.
- Возвращает `void *`, который нужно привести к целевому типу.

Поэтому основная рекомендация по операторам `new` и `delete` совпадает с рекомендацией по `malloc()` и `free()`: не используйте их.

## На уровень выше: выражения new и delete

Операторы (operators) `new` и `delete` могут участвовать в одноименных выражениях (expressions). Выражения [new](https://en.cppreference.com/w/cpp/language/new.html) и [delete](https://en.cppreference.com/w/cpp/language/delete.html) нужны, чтобы управлять памятью конкретного типа `T`:

```cpp
T * p = new T;

delete p;
```

Например:

```cpp
int * x = new int{6000};

*x += 2;
std::println("{}", *x);

delete x;
```
```
6002
```

При выполнении `int * x = new int{6000}` происходит следующее:
1. На куче выделяется память под тип `int`. Например, 4 байта. 
2. Она инициализируется целочисленным значением `6000`.
3. Оператор `new` возвращает указатель на эту память.
4. Указатель сохраняется в переменную `x`.

В момент вызова `delete x` выделенная память помечается свободной, а указатель `x` становится висячим (dangling pointer): он перестает указывать на корректную область памяти. В любой момент по этому адресу может быть создана другая переменная.

Если у типа есть конструктор, то он срабатывает при вызове `new` сразу после выделения памяти. При вызове `delete` сначала срабатывает деструктор, а потом освобождается память.

Создадим класс `Demo`, чтобы посмотреть в консоли стадии жизни объекта:

```cpp
class Demo
{
public:
    Demo()
    {
        std::println("Default constructor");
    }

    Demo(int a, int b)
    {
        std::println("Parameterized constructor. Args: {}, {}", a, b);
    }

    ~Demo()
    {
        std::println("Destructor");
    }

    void run()
    {
        std::println("Calling method");
    }
};
```

Заведем объект `Demo` в динамической памяти, вызовем его метод, а затем уничтожим:

```cpp
int main()
{
    Demo * d = new Demo{8, 9};
    d->run();
    delete d;
    std::println("Exiting main");
}
```
```
Parameterized constructor. Args: 8, 9
Calling method
Destructor
Exiting main
```

Обратите внимание, что разрушение объекта произошло до вывода строки `"Exiting main"`. 

## Выражения new[] и delete[] для массивов

У сишного массива константная длина. Если он создан глобально или помечен как `static`, то располагается в статической области памяти. В остальных случаях такой массив живет в автоматической памяти.

Есть способ превратить сишный массив в динамический и создать его на куче. Для этого используются версии операторов с квадратными скобками [new[]](https://en.cppreference.com/w/cpp/memory/new/operator_new.html) и [delete[]](https://en.cppreference.com/w/cpp/memory/new/operator_delete.html).

Так выглядит создание неинициализированного массива и его уничтожение:

```cpp
int n = 5;
int * arr = new int[n];

// ... Заполняем массив, работаем с ним

delete[] arr;
```

В квадратные скобки выражения `new T[n]` может быть передано любое целое положительное число. Оно не обязано быть константой. Квадратные скобки `delete[]` всегда пусты.

Чтобы инициализировать массив, в фигурных скобках перечисляются значения элементов:

```cpp
double * arr = new double[3]{1.0, 2.2, 7.8};

delete[] arr;
```

### Работа с динамической памятью на примере вектора

Теперь у нас есть все необходимое, чтобы написать свою реализацию вектора целых чисел. Она будет максимально примитивной, но работоспособной.

Сначала опишем интерфейс класса. А потом добавим реализацию методов.

```cpp
class Vector
{
public:
    // Создает пустой вектор
    Vector() = default;

    // Создает вектор из n элементов со значением val
    Vector(std::size_t n, int val);

    // Освобождает выделенную под вектор память
    ~Vector();

    // Возвращает количество элементов
    std::size_t size();

    // Возвращает емкость - под сколько элементов
    // выделена память
    std::size_t capacity();

    // Возвращает элемент по индексу. Если индекс за
    // пределами вектора, кидает исключение
    int & at(std::size_t i);

    // Возвращает элемент по индексу
    int & operator[](std::size_t i);

    // Увеличивает емкость вектора: выделяет под него
    // память бОльшего размера. Если значение capacity
    // меньше текущей емкости, то ничего не делает
    void reserve(std::size_t capacity);

    // Изменяет реальный размер вектора. Если новый размер
    // меньше текущего, удаляет элементы с конца. Если
    // больше, то добавляет элементы, инициализированные
    // значением по умолчанию. Если размеры равны, то
    // ничего не делает
    void resize(std::size_t size);

    // Добавляет элемент в конец
    void push_back(int val);

    // Удаляет последний элемент
    void pop_back();

    // Очищает вектор
    void clear();

private:
    // Перемещает элементы в область памяти под new_size элементов
    void move(std::size_t new_size);

    // Реальное количество элементов
    std::size_t m_size = 0;

    // Емкость: под сколько элементов выделена память
    std::size_t m_capacity = 0;

    // Указатель на сишный массив, в котором
    // хранятся элементы Vector
    int * m_elements = nullptr;
};
```

Обратите внимание метод `int & operator[](std::size_t i)`: он нужен для обращения к объекту `Vector` через синтаксис квадратных скобок. Подробнее про операторы будет в следующих главах.

Также мы завели приватный метод `move()`, который переиспользуем для реаллокации массива.

Поведение методов класса `Vector` максимально приблизим к [аналогичным методам](https://en.cppreference.com/w/cpp/container/vector.html) `std::vector`.

Заведем перегрузку конструктора для инициализации вектора `n` элементами, равными `val`.

```cpp
Vector::Vector(std::size_t n, int val):
        m_size{n},
        m_capacity{n},
        m_elements{new int[n]}
{
    for (std::size_t i = 0; i < m_size; ++i)
        m_elements[i] = val;
}
```

Выражение `new int[n]` выделяет память под сишный массив. Указатель на эту память инициализирует поле `m_elements` в [списке инициализации полей](/courses/cpp/chapters/cpp_chapter_0122/#block-member-initializer-list) конструктора.

Пример вызова этой перегрузки:

```cpp
Vector v{5, 9};
```

Сразу же определим деструктор:

```cpp
Vector::~Vector()
{
    delete[] m_elements;
}
```

На момент вызова деструктора `m_elements` может оказаться нулевым указателем. Это не страшно: если в `delete` передан `nullptr`, оператор не выполнит никаких действий.

Методы `size()` и `capacity()` просто возвращают значения соответствующих полей:

```cpp
std::size_t Vector::size()
{
    return m_size;
}

std::size_t Vector::capacity()
{
    return m_capacity;
}
```

Метод `at()` принимает индекс элемента и возвращает на него ссылку. Если индекс выходит за границы массива, кидается исключение:

```cpp
int & Vector::at(std::size_t i)
{
    if (i >= m_size)
    {
        throw std::out_of_range(
            std::format("Index {} is out of bounds. Vector size: {}",
            i, m_size));
    }

    return m_elements[i];
}
```

Есть ли в этом коде утечка памяти?

```cpp
int main()
{
    Vector numbers(4, 100);
    std::println("{}", numbers.at(5));
}
```

Да, есть! Мы завели вектор из 4-х элементов и обратились по индексу 5. Метод `at()` бросил исключение, и деструктор `Vector` не вызвался. А освобождение памяти по указателю `m_elements` организовано именно в деструкторе! Но утечка памяти тут чисто формальная. На практике она не интересна, потому что не обработанное исключение приводит к завершению программы. В этот момент отданная процессу память возвращается операционной системе.

Как насчет утечки в таком коде?

```cpp
int main()
{
    Vector numbers(4, 100);

    try
    {
        std::println("{}", numbers.at(5));
    }
    catch(const std::out_of_range & e)
    {
        std::println("Couldn't get element from vector: {}", e.what());
    }
}
```

В этом коде нет утечек памяти. Брошенное исключение перехватывается и происходит раскрутка стека (stack unwinding):
- Со стека удаляются фреймы всех функций до той, которая обрабатывает исключение.
- При снятии фрейма со стека происходит автоматическое удаление переменных из этого фрейма. Вызываются их деструкторы.
- Выполнение кода внутри блока `try` прерывается и управление передается блоку `catch`. Для локальных переменных блока `try` вызываются деструкторы.

Это означает, что для объекта `numbers` будет вызван деструктор. Вы можете открыть пример кода в песочнице и удостовериться в этом.

Реализация оператора `[]` выглядит даже проще метода `at()`:

```cpp
int & Vector::operator[](std::size_t i)
{
    return m_elements[i];
}
```

Перед тем как перейти к остальным публичным методам, реализуем вспомогатльный метод `move()`:

```cpp
void Vector::move(std::size_t new_size)
{
    int * new_elements = new int[new_size];

    m_size = std::min(m_size, new_size);

    for (std::size_t i = 0; i < m_size; ++i)
        new_elements[i] = m_elements[i];

    delete[] m_elements;
    m_elements = new_elements;

}
```

Что происходит в этом методе? Мы:
- Завели новый массив `new_elements` подходящего размера.
- Скопировали в него элементы из старого массива.
- Освободили область памяти, выдяленную под старый массив.
- Обновили значение указателя `m_elements`, чтобы он ссылался на новую область памяти.

Метод `move()` пригодится при реализации `reserve()` и `resize()`:

```cpp
void Vector::reserve(std::size_t capacity)
{
    if (capacity <= m_capacity)
        return;

    m_capacity = capacity;

    move(m_capacity);
}
```

Важно, что _за_ последним скопированным элементом в новом массиве может храниться любой мусор.

Метод `resize()` увеличивает фактический размер массива:

```cpp
void Vector::resize(std::size_t size)
{
    if (size == m_size)
        return;

    move(size);

    m_capacity = size;

    if (size > m_size)
    {
        for(std::size_t i = m_size; i < size; ++i)
            m_elements[i] = int{};
    }
}
```

Теперь напишем метод для добавления элемента в конец вектора.

```cpp
void Vector::push_back(int val)
{
    if (m_size + 1 > m_capacity)
        reserve(std::max(m_capacity, 1uz) * 2);

    m_elements[m_size++] = val;
}
```

Обратите внимание на использование постфиксной формы инкремента `m_size++`: она сначала возвращает значение, а потом увеличивает его. Поэтому в выражении `m_elements[m_size++]` не происходит выхода за границы массива.


И последний метод — `clear()`:

```cpp
void Vector::clear()
{
    m_size = 0;
}
```

Не смотря на название, метод всего лишь помечает его пустым, а не очищает массив.
 

## Указатели на указатели

## Возврат значения по указателю

## Умные указатели

----------

## Резюме
