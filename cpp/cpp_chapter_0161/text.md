# Глава 16.1. Основы работы с указателями

C++ — это низкоуровневый язык: он позволяет работать с памятью напрямую. Вы можете обратиться к памяти по конкретному адресу, вручную контроллировать ее выделение и освобождение.

Управление памятью завязано на концепцию указателей. Они лежат в основе реализации динамических структур данных: списков, динамических массивов, деревьев, хеш-таблиц. Вы найдете указатели под капотом большинства контейнеров стандартной библиотеки.

## Что такое указатель

[Указатель](https://en.cppreference.com/w/cpp/language/pointer.html) (pointer) — это переменная, которая хранит адрес в оперативной памяти. Отсюда и название: значение такой переменной как бы _указывает_ на область памяти. А адрес — это по сути число. Например, `0x55ae9a41c2a0`. Поэтому можно сказать, что указатель — это переменная, в которой лежит целое неотрицательное число, трактуемое компилятором как адрес.

Если указатель содержит адрес конкретной переменной, то через него можно получить к ней доступ. Такой доступ является _косвенным:_ вместо обращения к значению переменной напрямую сначала происходит обращение к указателю, а затем — по адресу, на который он указывает.

## Объявление указателя

При объявлении указателя между его типом и именем ставится символ звездочки `*`. Так выглядит объявление указателя `name` на переменную типа `T`:

```cpp
T * name;
```

Здесь символ `*` — это часть типа `T *`, а вовсе не оператор умножения. Как и у многих других символов, его смысл зависит от контекста.

Расставлять пробелы можно как угодно:

```cpp
T* name;
T * name;
T *name;
```

Разберем создание указателя на вектор:

```cpp
std::vector * p;
```

Что происходит на этой строке?
- Компилятор выделяет память под указатель `p`, но не под объект типа `std::vector`, на который указывает `p`. Вектор может уже существовать или создаваться дальше по коду.
- Компилятор не инициализирует выделенную память, ведь мы не присвоили указателю никакого значения. Как и при [инициализации по умолчанию](/courses/cpp/chapters/cpp_chapter_0131/#block-default-initialization) других типов, не имеющих конструктора, объект `p` может содержать любой мусор. Чтобы указатель ссылался на адрес переменной, нужно этот адрес получить.

## Оператор взятия адреса

[Оператора взятия адреса](https://en.cppreference.com/w/cpp/language/operator_member_access.html#Built-in_address-of_operator) (address-of operator) `&` — это унарный оператор, который ставится перед своим операндом и возвращает его адрес:

```cpp
bool b = true;

// Инициализируем указатель b_ptr адресом переменной b
bool * b_ptr = &b;
```


![Указатели](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-15/illustrations/cpp/pointers.jpg) {.illustration}


В данном контексте символ `&` не имеет ничего общего с объявлением ссылки или логическим «И». При объявлении ссылки символ `&` относится к типу. А при взятии адреса он ставится перед уже существующей переменной. Сравните:

```cpp
int x = 5;

int & ref = x;  // Это - объявление ссылки на x

int * ptr = &x; // А это - инициализация указателя адресом x
```

### Как вывести в консоль адрес объекта

Чтобы вывести адрес объекта в консоль, нужно явно привести его к типу указателя `void *`. 

```cpp
std::println("{}", static_cast<void *>(&x));
```
```
0x7ffe4f884814
```

Тип `void` указателя означает, что он [может ссылаться](https://timsong-cpp.github.io/cppwp/n4868/basic.compound#5) на адрес объекта любого типа. Явное приведение типа неудобно, зато подчеркивает намерение получить адрес:

```cpp
int val = 256;
int * ptr = &val;

std::println("val={}. Address: {}", val, static_cast<void *>(&val));
std::println("ptr={}", static_cast<void *>(ptr));
```
```
val=256. Address: 0x7ffe4f884814
ptr=0x7ffe4f884814
```

Чтобы в строке форматирования указать, что в данном месте будет подставлен указатель, можно добавить [спецификатор](https://en.cppreference.com/w/cpp/utility/format/spec.html) `p`:

```cpp
std::println("ptr={:p}", static_cast<void *>(ptr));
```
```
ptr=0x7ffd6df3c614
```

А чтобы вывести адрес в верхнем регистре, используется спецификатор `P`:

```cpp
std::println("ptr={:P}", static_cast<void *>(ptr));
```
```
ptr=0X7FFDA8185ED4
```

## Оператор разыменования

Чтобы обратиться к переменной, на которую ссылается указатель, перед указателем ставится [оператор разыменования](https://en.cppreference.com/w/cpp/language/operator_member_access.html#Built-in_indirection_operator) (dereference operator) `*`. Он также известен как оператор косвенного обращения (indirection operator), потому что через указатель открывает косвенный доступ к объекту.

```cpp
int x = 504;
int * x_ptr = &x;

// Через указатель x_ptr косвенно обращаемся к x
std::println("{}", *x_ptr);
```
```
504
```

Применение оператора `*` к указателю называется **разыменованием указателя.** Так, `*x_ptr` читается как «разыменование указателя `x_ptr`» или «обращение по указателю `x_ptr`».

Указатель типа `void *` нельзя разыменовывать: компилятору неизвестно, на переменную какого размера ссылается такой указатель, и поэтому не может корректно работать с ее значением.

Разыменование необходимо и для чтения, и для _записи_ данных, адрес которых хранит указатель:

```cpp
// Изменяем значение переменной, на которую указывает x_ptr
*x_ptr = 200;
std::println("{}", x);
```
```
200
```

Приоритет оператора взятия адреса `&` и оператора разыменования `*` [такой же,](https://en.cppreference.com/w/cpp/language/operator_precedence.html) как у пре-инкремента, и ниже, чем у пост-инкремента. Поэтому не забывайте правильно расставлять скобки.

```cpp
// Делаем инкремент значения, на которое указывает x_ptr
(*x_ptr)++;
std::println("{}", x);
```
```
201
```

Что выведет этот код? {.task_text}

```cpp {.example_for_playground}
std::uint16_t code = 100;

std::uint16_t * p = &code;

*p += *p * 3;

std::println("{}", *p);
```

```consoleoutput {.task_source #cpp_chapter_0161_task_0010}
```
. {.task_hint}
```cpp {.task_answer}
400
```

## Размер указателя

Сколько памяти выделяется под указатель? Ее должно быть достаточно, чтобы указатель мог хранить _любой_ адрес оперативной памяти. Но конкретное значение размера указателя зависит в основном от целевой ОС и архитектуры. Так, в большинстве реализаций под 32-битные платформы указатель занимает 4 байта, а под 64-битные — 8 байт.

Размер указателя **не зависит** от типа, на который он указывает.

Сколько байт занимает указатель в нашем [плэйграунде?](https://senjun.ru/playground/cpp/) {.task_text}

```consoleoutput {.task_source #cpp_chapter_0161_task_0020}
```
Откройте плэйграунд и примените оператор `sizeof` у указателю. {.task_hint}
```cpp {.task_answer}
8
```

Что выведет этот код? {.task_text}

```cpp
std::vector * p_vec;
bool * p_bool;

std::println("{}", sizeof(p_vec) == sizeof(b_bool));
```

```consoleoutput {.task_source #cpp_chapter_0161_task_0030}
```
Размер указателя не зависит от типа, на который он указывает. {.task_hint}
```cpp {.task_answer}
true
```

## Нулевой указатель

В отличие от ссылок, указатель не требуется инициализировать конкретным адресом. Его можно присвоить и после создания.

```cpp
std::size_t a = 16;
std::size_t b = 32;

std::size_t *  ptr;
ptr = &a;
ptr = &b;
```

Главное — помнить, что указатель, как и любая другая переменная, должен быть инициализированным:

```cpp
int * ptr; // В ptr может лежать любой мусор

std::println("{}", *ptr); // UB
```

Если указатель не ссылается на конкретный объект, обязательно присваивайте ему значение [nullptr](https://en.cppreference.com/w/cpp/language/nullptr.html). Это ключевое слово и одновременно литерал, означающий, что указатель не хранит адрес объекта:

```cpp
int * ptr = nullptr;
```

Литерал `nullptr` появился в C++11. В более старом коде вместо него используется макрос `NULL`:

```cpp
int * ptr = NULL;
```

Определение `NULL` выглядит примерно так:

```cpp
#define NULL 0
```

Поэтому в принципе можно инициализировать указатель и числом 0, хотя делать так не рекомендуется:

```cpp
int * ptr = 0;
```

Почему 0 не может быть корректным адресом? Если вы не знаете, то [взгляните](/courses/cpp/chapters/cpp_chapter_0090/#block-virtual-address) на то, как устроено виртуальное адресное пространство процесса.

У `nullptr` тип [std::nullptr_t](https://en.cppreference.com/w/cpp/types/nullptr_t.html), а `NULL` и `0` — это числа. Но все они совместимы между собой благодаря [неявному приведению типов.](/courses/cpp/chapters/cpp_chapter_0010/#block-implicit-cast) 

```cpp
import std;

#include <cstddef> // Хедер содержит объявление макроса NULL

int main()
{
    int * ptr = nullptr;

    std::println("{}", (ptr == NULL) && (ptr == 0));
    std::println("{}", static_cast<void *>(ptr));
}
```
```
true
0x0
```

В современном C++ предпочтение отдается `nullptr`: его использование явно разграничивает, в каком случае идет работа с числами, а в каком — с указателем. 

Указатель, равный `nullptr`, `NULL` или 0, называется **нулевым указателем.** Если указатель не хранит адрес конкретного объекта, всегда делайте его нулевым. Но помните, что разыменование нулевого указателя — это тоже UB:

```cpp
int * ptr = nullptr;

std::println("{}", *ptr); // Так делать нельзя
```

Поэтому если по логике программы указатель _может_ оказаться нулевым, перед его разыменованием добавляйте проверку на `nullptr`.

```cpp
int * ptr = nullptr;

// ...

if (ptr == nullptr)
    std::println("Null pointer");
else
    std::println("{}", *ptr);
```

Чаще всего проверку вида `ptr != nullptr` записывают более лаконично:

```cpp
if (ptr)
{
    // Здесь ptr не равен nullptr
}
```

Соответственно если нужно выполнить код при условии `ptr == nullptr`, это записывается так:

```cpp
if (!ptr)
{
    // Здесь ptr равен nullptr
}
```

Такие варианты проверок работают благодаря неявному приведению `nullptr` к `false` и остальных значений указателя — к `true`.

Что выведет этот код? Введите `err` в случае ошибки компиляции или `ub`, если поведение не определено. {.task_text}

```cpp {.example_for_playground}
import std;

int main()
{
    void * self = &self;
    std::println("{}", static_cast<bool>(self));
}
```

```consoleoutput {.task_source #cpp_chapter_0161_task_0050}
```
В момент инициализации `self` своим же адресом эта переменная [уже существует,](https://timsong-cpp.github.io/cppwp/std23/basic.scope.pdecl#1) поэтому ошибки компиляции нет. В `self` сохраняется ее же адрес, и он точно не равен `nullptr`. А приведение любого не нулевого числа к `bool` — это `true`. {.task_hint}
```cpp {.task_answer}
true
```


## Оператор доступа к полям и методам класса

Допуcтим, у нас есть указатель на объект класса `std::pair`:

```cpp
std::pair<std::string, bool> res = {"/", true};

std::pair<std::string, bool> * res_ptr = &res;
```

Обращение к полям объекта осуществляется через оператор `.`. Его приоритет выше, чем у оператора разыменования `*`. Но чтобы обратиться к полю объекта, нужно сначала получить к нему косвенный доступ, разыменовав указатель. Чтобы поменять порядок применения операторов, используем скобки:

```cpp
(*res_ptr).first = "/etc/search.yaml"; // обращаемся к полю

std::println("{} {}", (*res_ptr).first, (*res_ptr).second);
```
```
/etc/search.yaml true
```

Аналогичным образом выглядит вызов метода объекта:

```cpp
std::string uuid = "a674b109-b08d-433a-aed4-7e03861345d0";

std::string * p = &uuid;

std::size_t len = (*p).size(); // вызываем метод строки

std::println("{}", len);
```
```
36
```

Синтаксис вида `(*p).field` слишком громоздкий. Удобнее использовать оператор `->` для косвенного доступа к полю или методу класса через указатель. Считайте `p->field` синтаксическим сахаром, по сути не отличающимся от `(*p).field`.

```cpp
res_ptr->first = "/etc/search.yaml"; // обращаемся к полю
```

```cpp
std::size_t len = p->size(); // вызываем метод строки
```

## Передача параметров по указателю

В C++ существует три способа передачи в функцию параметров:
- По значению (by value).
- По ссылке (by reference).
- По указателю (by pointer).

В прошлой главе мы [рассмотрели](/courses/cpp/chapters/cpp_chapter_0150/#block-func) передачу по значению и по ссылке. При передаче по значению функция работает с копией объекта, а при передаче по ссылке — с исходным объектом.

Как и передача по ссылке, передача по указателю нужна, чтобы избежать копирования: функция получает указатель и через него косвенно обращается к исходному объекту.

```cpp
import std;

struct ConfValue
{
    std::string section;
    std::string name;
    std::string value;
};

bool is_set(ConfValue * conf_val) // Принимаем conf_val по указателю
{
    return !conf_val->value.empty();
}

int main()
{
    ConfValue v{"net", "ip", "127.0.0.1"};
    std::println("{}", is_set(&v));    // Передаем адрес v

    ConfValue * v_ptr = &v;
    std::println("{}", is_set(v_ptr)); // Передаем указатель v_ptr
}
```
```
true
true
```

Под капотом передача параметра по ссылке и по указателю сводится к одному и тому же: в функцию попадает адрес объекта, и функция работает с этим объектом.

## Указатели и константность

Как вы [помните,](/courses/cpp/chapters/cpp_chapter_0150/#block-const) константная ссылка и ссылка на константный объект — это одно и то же. В случае с указателями все разнообразнее. Константный указатель и указатель на константный объект — это разные вещи.

**Константный указатель** нельзя «перевесить» на другой объект, зато сам объект изменять через него можно:

```cpp
bool is_authorized = true;
bool * const p = &is_authorized; // Константный указатель

*p = false;                      // Ок
p = nullptr;                     // ошибка
```

**Указатель на константный объект** можно переназначить, но объект через него модифицировать не получится:

```cpp
bool is_authorized = true;
const bool * p = &is_authorized; // Указатель на константу

*p = false;                      // Ошибка
p = nullptr;                     // Ок
```

И, наконец, **константный указатель на константный объект** не разрешает ни переприсваивать указатель, ни изменять объект.

Правило расстановки `const` при объявлении указателей легко запомнить:
- Если константность относится к объекту, то `const` ставится слева от `*`. То есть рядом с типом объекта.
- Если константность относится к указателю, то `const` ставится справа.


![Указатели и константность](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-16/illustrations/cpp/const_pointers.jpg) {.illustration}


На какой строке кода допущена ошибка? Введите `0`, если ошибок нет и код скомпилируется. {.task_text}

```cpp
std::vector<int> v = {1, 5, 10};   // 1
std::vector<int> * const ptr = &v; // 2

v->clear();                        // 3
v = nullptr;                       // 4
```

```consoleoutput {.task_source #cpp_chapter_0161_task_0040}
```
Указатель `ptr` является константным. {.task_hint}
```cpp {.task_answer}
4
```

Попробуем вывести в консоль указатель, у которого есть константность.

```cpp
const int * ptr = &val;

std::println("{}", static_cast<void *>(ptr));
```
```
main.cpp:8:25: error: static_cast from 'const int *' to 'void *' is not allowed
    8 | std::println("{}", static_cast<void *>(ptr));
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~
```

Ошибка компиляции говорит о том, что нельзя привести тип `const T *` к `void *`, то есть убрать константность. Поэтому нужно правильно расставить `const` в результирующем типе `void *`:

```cpp
const int * ptr = &val;

std::println("{:p}", static_cast<const void *>(ptr));
```
```
0x7ffc36211234
```

## Когда использовать указатели, а когда — ссылки

Вот несколько простых правил, которые помогут при выборе между ссылками и указателями:
- По умолчанию [предпочитайте](https://isocpp.org/wiki/faq/references#refs-vs-ptrs) ссылки.
- Ссылка не может быть переназначена на другой объект или обнулена, а указатель — может. Если без этого не обойтись, используйте указатель.
- Используйте указатель, если под объект нужно динамически выделять память. Этому посвящена следующая глава.

----------

## Резюме
- Указатель — это переменная, хранящая адрес в оперативной памяти.
- В типе указателя должен присутствовать символ `*`. Например, `std::string *` — это указатель на строку.
- Чтобы присвоить указателю адрес переменной, к ней применяется оператор взятия адреса `&`. Например, `&val` читается как «взятие адреса `val`».
- Чтобы через указатель косвенно обратиться к переменной, перед ним ставится оператор разыменования `*`. Так, `*p` читается как «разыменование `p`».
- Константный указатель не дает переназначать указателю новый адрес, а указатель на константный объект не дает изменять объект.
- Адресная арифметика — это операции сложения, вычитания и сравнения применительно к указателям. Они нужны, чтобы перемещать указатель по памяти с учетом его типа.

