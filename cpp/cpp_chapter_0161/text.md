# Глава 16.1. Работа с указателями

C++ — это низкоуровневый язык: он позволяет работать с памятью напрямую. Вы можете обратиться к памяти по конкретному адресу, вручную контроллировать ее выделение и освобождение. Управление памятью завязано на концепцию указателей. Они лежат в основе реализации динамических структур данных: списков, динамических массивов, деревьев, хеш-таблиц. Вы найдете указатели под капотом большинства контейнеров стандартной библиотеки.

## Что такое указатель

[Указатель](https://en.cppreference.com/w/cpp/language/pointer.html) (pointer) — это переменная, которая хранит адрес в оперативной памяти. Отсюда и название: значение такой переменной как бы _указывает_ на область памяти. А адрес — это по сути число. Например, `0x55ae9a41c2a0`. Поэтому можно сказать, что указатель — это переменная, в которой лежит целое неотрицательное число, трактуемое компилятором как адрес.

Если указатель содержит адрес конкретной переменной, то через него можно получить к ней доступ. Такой доступ является _косвенным:_ вместо обращения к значению переменной напрямую сначала происходит обращение к указателю, а затем — по адресу, на который он указывает.

## Объявление указателя

При объявлении указателя между его типом и именем ставится символ звездочки `*`. Так выглядит объявление указателя `name` на переменную типа `T`:

```cpp
T * name;
```

 Здесь символ `*` является частью типа `T *`, а вовсе не оператором умножения. Как и у многих других символов, его смысл зависит от контекста.

Расставлять пробелы можно как угодно:

```cpp
T* name;
T * name;
T *name;
```

А это — создание указателя на вектор:

```cpp
std::vector * p;
```

Что происходит на этой строке?
- Компилятор выделяет память под указатель `p`, но не под объект типа `std::vector`, на который указывает `p`. Вектор может уже существовать или создаваться дальше по коду.
- Компилятор не инициализирует выделенную память, ведь мы не присвоили указателю никакого значения. Как и при [инициализации по умолчанию](/courses/cpp/chapters/cpp_chapter_0131/#block-default-initialization) других типов, не имеющих конструктора, объект `p` может содержать произвольный мусор. Чтобы указатель ссылался на адрес переменной, нужно этот адрес получить.

## Оператор взятия адреса

[Оператора взятия адреса](https://en.cppreference.com/w/cpp/language/operator_member_access.html#Built-in_address-of_operator) (address-of operator) `&` — это унарный оператор, который ставится перед своим операндом и возвращает его адрес:

```cpp
bool b = true;

// Инициализируем указатель b_ptr адресом переменной b
bool * b_ptr = &b;
```


![Указатели](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-15/illustrations/cpp/pointers.jpg) {.illustration}


В данном контексте символ `&` не имеет ничего общего с объявлением ссылки или логическим «И». При объявлении ссылки символ `&` относится к типу. А при взятии адреса он ставится перед уже существующей переменной. Сравните:

```cpp
int x = 5;

int & ref = x;  // Это - объявление ссылки на x

int * ptr = &x; // А это - инициализация указателя адресом x
```

### Как вывести в консоль адрес объекта

Чтобы вывести адрес объекта в консоль, нужно явно привести его к типу указателя `void *`. 

```cpp
std::println("{}", static_cast<void *>(&x));
```
```
0x7ffe4f884814
```

Тип `void` указателя означает, что он может ссылаться на адрес объекта любого типа. Явное приведение типа неудобно, зато подчеркивает намерение получить адрес, а не значение:

```cpp
int val = 256;
int * ptr = &val;

std::println("val={}. Address: {}", val, static_cast<void *>(&val));
std::println("ptr={}", static_cast<void *>(ptr));
```
```
val=256. Address: 0x7ffe4f884814
ptr=0x7ffe4f884814
```

## Оператор разыменования

Чтобы обратиться к переменной, на которую ссылается указатель, перед указателем ставится [оператор разыменования](https://en.cppreference.com/w/cpp/language/operator_member_access.html#Built-in_indirection_operator) (dereference operator) `*`. Он также известен как оператор косвенного обращения (indirection operator), потому что через указатель открывает косвенный доступ к объекту.

```cpp
int x = 504;
int * x_ptr = &x;

// Через указатель x_ptr косвенно обращаемся к x
std::println("{}", *x_ptr);
```
```
504
```

Применение оператора `*` к указателю называется **разыменованием указателя.** Так, `*x_ptr` читается как «разыменование указателя `x_ptr`» или «обращение по указателю `x_ptr`».

Указатель типа `void *` нельзя разыменовывать: компилятору неизвестно, на переменную какого размера ссылается такой указатель, и поэтому не может корректно работать с ее значением.

Разыменование необходимо и для чтения, и для _записи_ данных, адрес которых хранит указатель:

```cpp
// Изменяем значение переменной, на которую указывает x_ptr
*x_ptr = 200;
std::println("{}", x);
```
```
200
```

Приоритет оператора взятия адреса `&` и оператора разыменования `*` [такой же,](https://en.cppreference.com/w/cpp/language/operator_precedence.html) как у пре-инкремента, и ниже, чем у пост-инкремента. Поэтому не забывайте правильно расставлять скобки.

```cpp
// Делаем инкремент значения, на которое указывает x_ptr
(*x_ptr)++;
std::println("{}", x);
```
```
201
```

Что выведет этот код? {.task_text}

```cpp {.example_for_playground}
std::uint16_t code = 100;

std::uint16_t * p = &code;

*p += *p * 3;

std::println("{}", *p);
```

```consoleoutput {.task_source #cpp_chapter_0150_task_0010}
```
. {.task_hint}
```cpp {.task_answer}
400
```

## Размер указателя

Сколько памяти выделяется под указатель? Ее должно быть достаточно, чтобы указатель мог хранить _любой_ адрес оперативной памяти. Но конкретное значение размера указателя зависит в основном от целевой ОС и архитектуры. Так, в большинстве реализаций под 32-битные платформы указатель занимает 4 байта, а под 64-битные — 8 байт.

Размер указателя **не зависит** от типа, на который он указывает.

Сколько байт занимает указатель в нашем [плэйграунде?](https://senjun.ru/playground/cpp/) {.task_text}

```consoleoutput {.task_source #cpp_chapter_0160_task_0010}
```
Откройте плэйграунд и примените оператор `sizeof` у указателю. {.task_hint}
```cpp {.task_answer}
8
```

Что выведет этот код? {.task_text}

```cpp
std::vector * p_vec;
bool * p_bool;

std::println("{}", sizeof(p_vec) == sizeof(b_bool));
```

```consoleoutput {.task_source #cpp_chapter_0160_task_0020}
```
Размер указателя не зависит от типа, на который он указывает. {.task_hint}
```cpp {.task_answer}
true
```

## Нулевой указатель

В отличие от ссылок, указатель не требуется инициализировать конкретным адресом. Его можно присвоить и после создания.

```cpp
std::size_t a = 16;
std::size_t b = 32;

std::size_t *  ptr;
ptr = &a;
ptr = &b;
```

Главное — помнить, что указатель, как и любая другая переменная, должен быть инициализированным:

```cpp
int * ptr; // В ptr может лежать любой мусор

std::println("{}", *ptr); // UB
```

Если указатель не ссылается на конкретный объект, обязательно присваивайте ему значение [nullptr](https://en.cppreference.com/w/cpp/language/nullptr.html). Это ключевое слово и одновременно литерал, означающий, что указатель не хранит адрес объекта:

```cpp
int * ptr = nullptr;
```

Литерал `nullptr` появился в C++11. В более старом коде вместо него используется макрос `NULL`:

```cpp
int * ptr = NULL;
```

Определение `NULL` выглядит примерно так:

```cpp
#define NULL 0
```

Поэтому в принципе можно инициализировать указатель и числом 0, хотя делать так не рекомендуется:

```cpp
int * ptr = 0;
```

Почему 0 не может быть корректным адресом? Если вы не знаете, то [взгляните](/courses/cpp/chapters/cpp_chapter_0090/#block-virtual-address) на то, как устроено виртуальное адресное пространство процесса.

У `nullptr` тип [std::nullptr_t](https://en.cppreference.com/w/cpp/types/nullptr_t.html), а `NULL` и `0` — это числа. Но все они совместимы между собой благодаря [неявному приведению типов.](/courses/cpp/chapters/cpp_chapter_0010/#block-implicit-cast) 

```cpp
import std;

#include <cstddef> // Хедер содержит объявление макроса NULL

int main()
{
    int * ptr = nullptr;

    std::println("{}", (ptr == NULL) && (ptr == 0));
    std::println("{}", static_cast<void *>(ptr));
}
```
```
true
0x0
```

В современном C++ предпочтение отдается `nullptr`: его использование явно разграничивает, в каком случае идет работа с числами, а в каком — с указателем. 

Указатель, равный `nullptr`, `NULL` или 0, называется **нулевым указателем.** Если указатель не хранит адрес конкретного объекта, всегда делайте его нулевым. Но помните, что разыменование нулевого указателя — это тоже UB:

```cpp
int * ptr = nullptr;

std::println("{}", *ptr); // Так делать нельзя
```

Поэтому если по логике программы указатель _может_ оказаться нулевым, перед его разыменованием добавляйте проверку на `nullptr`.

```cpp
int * ptr = nullptr;

// ...

if (ptr == nullptr)
    std::println("Null pointer");
else
    std::println("{}", *ptr);
```

Чаще всего проверку вида `ptr != nullptr` записывают более лаконично:

```cpp
if (ptr)
{
    // Здесь ptr не равен nullptr
}
```

Соответственно если нужно выполнить код при условии `ptr == nullptr`, это записывается так:

```cpp
if (!ptr)
{
    // Здесь ptr равен nullptr
}
```

Такие варианты проверок работают благодаря неявному приведению `nullptr` к `false` и остальных значений указателя — к `true`.

## Оператор доступа к полям и методам класса

Допуcтим, у нас есть указатель на объект класса `std::pair`:

```cpp
std::pair<std::string, bool> res = {"/", true};

std::pair<std::string, bool> * res_ptr = &res;
```

Обращение к полям объекта осуществляется через оператор `.`. Его приоритет выше, чем у оператора разыменования `*`. Но чтобы обратиться к полю объекта, нужно сначала получить к нему косвенный доступ, разыменовав указатель. Чтобы поменять порядок применения операторов, используем скобки:

```cpp
(*res_ptr).first = "/etc/search.yaml"; // обращаемся к полю

std::println("{} {}", (*res_ptr).first, (*res_ptr).second);
```
```
/etc/search.yaml true
```

Аналогичным образом выглядит вызов метода объекта:

```cpp
std::string uuid = "a674b109-b08d-433a-aed4-7e03861345d0";

std::string * p = &uuid;

std::size_t len = (*p).size(); // вызываем метод строки

std::println("{}", len);
```
```
36
```

Синтаксис вида `(*p).field` слишком громоздкий. Удобнее использовать оператор `->` для косвенного доступа к полю или методу класса через указатель. Считайте `p->field` синтаксическим сахаром, по сути не отличающимся от `(*p).field`.

```cpp
res_ptr->first = "/etc/search.yaml"; // обращаемся к полю
```

```cpp
std::size_t len = p->size(); // вызываем метод строки
```

## Передача параметров по указателю

В C++ существует три способа передачи в функцию параметров:
- По значению (by value).
- По ссылке (by reference).
- По указателю (by pointer).

В прошлой главе мы [рассмотрели](/courses/cpp/chapters/cpp_chapter_0150/#block-func) передачу по значению и по ссылке. При передаче по значению функция работает с копией объекта, а при передаче по ссылке — с исходным объектом.

Как и передача по ссылке, передача по указателю нужна, чтобы избежать копирования: функция получает указатель и через него косвенно обращается к исходному объекту.

```cpp
import std;

struct ConfValue
{
    std::string section;
    std::string name;
    std::string value;
};

bool is_set(ConfValue * conf_val) // Принимаем conf_val по указателю
{
    return !conf_val->value.empty();
}

int main()
{
    ConfValue v{"net", "ip", "127.0.0.1"};
    std::println("{}", is_set(&v));    // Передаем адрес v

    ConfValue * v_ptr = &v;
    std::println("{}", is_set(v_ptr)); // Передаем указатель v_ptr
}
```
```
true
true
```

Под капотом передача параметра по ссылке и по указателю сводится к одному и тому же: в функцию попадает адрес объекта, и функция работает с этим объектом.

## Указатели и константность

Как вы [помните,](/courses/cpp/chapters/cpp_chapter_0150/#block-const) константная ссылка и ссылка на константный объект — это одно и то же. В случае с указателями все разнообразнее. Константный указатель и указатель на константный объект — это разные вещи.

**Константный указатель** нельзя «перевесить» на другой объект, зато сам объект изменять через него можно:

```cpp
bool is_authorized = true;
bool * const p = &is_authorized; // Константный указатель

*p = false;                      // Ок
p = nullptr;                     // ошибка
```

**Указатель на константный объект** можно переназначить, но объект через него модифицировать не получится:

```cpp
bool is_authorized = true;
const bool * p = &is_authorized; // Указатель на константу

*p = false;                      // Ошибка
p = nullptr;                     // Ок
```

И, наконец, **константный указатель на константный объект** не разрешает ни переприсваивать указатель, ни изменять объект.

Правило расстановки `const` при объявлении указателей легко запомнить:
- Если константность относится к объекту, то `const` ставится слева от `*`. То есть рядом с типом объекта.
- Если константность относится к указателю, то `const` ставится справа.


![Указатели и константность](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-16/illustrations/cpp/const_pointers.jpg) {.illustration}


На какой строке кода допущена ошибка? Введите `0`, если ошибок нет и код скомпилируется. {.task_text}

```cpp
std::vector<int> v = {1, 5, 10};   // 1
std::vector<int> * const ptr = &v; // 2

v->clear();                        // 3
v = nullptr;                       // 4
```

```consoleoutput {.task_source #cpp_chapter_0160_task_0030}
```
Указатель `ptr` является константным. {.task_hint}
```cpp {.task_answer}
4
```

## Адресная арифметика

Итак, указатель — это переменная, хранящая адрес. И размер указателя не зависит от типа, на который он ссылается. Зачем тогда вообще сообщать компилятору об этом типе в момент объявления? Какая разница, чей адрес содержит указатель — `bool`, `long int` или `std::queue`?

Память упрощенно можно представить как массив ячеек по 1 байту. Кстати, именно поэтому нельзя завести переменную размером, например, в 3 бита или в 11 бит при условии, что байт равен 8 бит.

Допустим, у нас есть три локальных переменных размером в 1, 4 и 8 байт:


![Переменные в адресном пространстве](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-16/illustrations/cpp/pointers_and_addresses.jpg) {.illustration}


И если бы мы захотели по указателю `p` обновить значение `retry`, но компилятор имел бы неверное представление о размере этой переменной, то вместо перезаписи 1 байта мы могли бы затереть 4, 8 или больше. Мы бы повредили значения соседних переменных. А возможно, даже испортили бы значения ячеек, в которых расположен сам указатель! Эта ситуация называется **повреждением памяти** (memory corruption).

### Прибавление к указателю целого числа

Еще одна причина, по которой компилятору важно знать о типе, на который ссылается указатель — это **адресная арифметика.**  С помощью указателей можно перемещаться по памяти, и для этого к указателям применяются арифметические операции `+`, `-`  и сравнение. И работают они с учетом типа указателя.

Адресную арифметику удобнее всего разбирать на примере указателей на сишные массивы. Как вы [помните,](/courses/cpp/chapters/cpp_chapter_0142/#block-c-array-under-the-hood) элементы сишных массивов расположены друг за другом _в непрерывной области памяти._ Убедимся в этом: переберем в цикле все элементы массива и выведем их адреса.

```cpp
const std::size_t n = 5;
int arr[n] = {16, 32, 64, 128, 256};

for (std::size_t i = 0; i < n; ++i)
{
    std::println("Address: {}. arr[{}]={}",
                 static_cast<void *>(&arr[i]), i, arr[i]);
}
```
```
Address: 0x7fffcb3c3550. arr[0]=16
Address: 0x7fffcb3c3554. arr[1]=32
Address: 0x7fffcb3c3558. arr[2]=64
Address: 0x7fffcb3c355c. arr[3]=128
Address: 0x7fffcb3c3560. arr[4]=256
```

Создадим указатель `p` на целое число и установим его на нулевой элемент:

```cpp
int * p = &arr[0];
```

Вместо этой записи чаще всего используют более лаконичную:

```cpp
int * p = arr;
```

Она означает то же самое: установку указателя на адрес нулевого элемена.

А теперь начнем смещать указатель `p` по массиву. Делается это с помощью обычного инкремента, например `++p`. 

Когда к указателю прибавляется целое число, то значение указателя увеличивается на соответствующее значение, умноженное на размер типа данных указателя. Если прибавить к указателю число, не превышающее длину массива, то он будет ссылаться на один из последующих элементов. Важно следить, чтобы указатель не вышел за границы массива. Обращение по такому указателю приведет к UB.

```cpp
const std::size_t n = 5;
int arr[n] = {16, 32, 64, 128, 256};
    
int * p = &arr[0];
std::println("{}", *p);  // 16

++p;
std::println("{}", *p);  // 32

p += 2;
std::println("{}", *p);  // 128

++p;                     // Выход за пределы массива
std::println("{}", *p);  // UB
```


![Перемещение по массиву с помощью указателя](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-16/illustrations/cpp/pointer_to_array_element.jpg) {.illustration}


### Вычитание из указателя целого числа

Вычитание целых чисел из указателей работает по этой же схеме: вычитается значение, умноженное на размер типа.

```cpp
const std::size_t n = 5;
int arr[n] = {16, 32, 64, 128, 256};
    
int * p = &arr[3];
std::println("{}", *p);  // 128

p--;
std::println("{}", *p);  // 64

p -= 2;
std::println("{}", *p);  // 16

--p;                     // Выход за пределы массива
std::println("{}", *p);  // UB
```

### Вычитание указателей

Указатели можно вычитать один из другого. Для этого у них должен быть одинаковый тип и они должны ссылаться на области непрерывного участка памяти. Например, указывать на элементы одного и того же массива.

```cpp
const std::size_t n = 5;
int arr[n] = {16, 32, 64, 128, 256};

// Указатель на нулевой элемент массива:
int * p1 = arr;  // Мы могли бы написать и так: &arr[0]

int * p2 = &arr[3];

std::println("{}", p2 - p1);
```
```
3
```

Разность между указателями равна количеству объектов заданного типа между ними, а вовсе не количестсву байт! При вычитании указателей компилятор делит получившееся значение на размер типа данных. Поэтому через разность указателей на элементы массива можно определять расстояние между ними.

### Сравнение указателей

К указателям применимо сравнение операторами `>`, `>=`, `<`, `<=`, `==` и `!=`. При этом происходит сравнение адресов, на которые они указывают. Сравнение на больше-меньше имеет смысл только в случае, если указатели ссылаются на один и тот же блок памяти.


### Когда использовать указатели, а когда — ссылки

Вот несколько простых правил, которые помогут при выборе между ссылками и указателями:
- По умолчанию [предпочитайте](https://isocpp.org/wiki/faq/references#refs-vs-ptrs) ссылки.
- Ссылка не может быть переназначена на другой объект или обнулена, а указатель — может. Если без этого не обойтись, используйте указатель.
- Используйте указатель, если под объект нужно динамически выделять память. Этому посвящена следующая глава.

----------

## Резюме
- Указатель — это переменная, хранящая адрес в оперативной памяти.
- В типе указателя должен присутствовать символ `*`. Например, `std::string *` — это указатель на строку.
- Чтобы присвоить указателю адрес переменной, к ней применяется оператор взятия адреса `&`. Например, `&val` читается как «взятие адреса `val`».
- Чтобы через указатель косвенно обратиться к переменной, перед ним ставится оператор разыменования `*`. Так, `*p` читается как «разыменование `p`».
- Константный указатель не дает переназначать указателю новый адрес, а указатель на константный объект не дает изменять объект.
- Адресная арифметика — это операции сложения, вычитания и сравнения применительно к указателям. Они нужны, чтобы перемещать указатель по памяти с учетом его типа.

