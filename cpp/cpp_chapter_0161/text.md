# Глава 16.1. Основы работы с указателями

C++ — это высокоуровневый язык низкоуровневыми возможностями. С одной стороны, в нем есть средства для построения абстракций, в первую очередь классы и шаблоны. С другой стороны, вы можете спуститься на уровень, максимально близкий к аппаратному, и работать с памятью напрямую. C++ позволяет обращаться к памяти по конкретному адресу, вручную контроллировать ее выделение и освобождение.

Управление памятью завязано на концепцию указателей. Они лежат в основе реализации динамических структур данных: списков, динамических массивов, деревьев, хеш-таблиц. Вы найдете указатели под капотом у контейнеров стандартной библиотеки.

## Что такое указатель

[Указатель](https://en.cppreference.com/w/cpp/language/pointer.html) (pointer) — это переменная, которая хранит адрес в оперативной памяти. Отсюда и название: значение такой переменной как бы _указывает_ на область памяти. А адрес — это по сути число. Например, `0x55ae9a41c2a0`. Поэтому можно сказать, что указатель — это переменная, в которой лежит целое неотрицательное число, трактуемое компилятором как адрес.

Если указатель содержит адрес конкретной переменной, то через него можно получить к ней доступ. Такой доступ является _косвенным:_ вместо обращения к значению переменной напрямую сначала происходит обращение к указателю, а затем — по адресу, на который он указывает.

## Объявление указателя

При объявлении указателя между его типом и именем ставится символ звездочки `*`. Так выглядит объявление указателя `name` на переменную типа `T`:

```cpp
T * name;
```

Здесь символ `*` — это часть типа `T *`, а вовсе не оператор умножения. Как и у многих других символов, его смысл зависит от контекста.

Расставлять пробелы можно как угодно:

```cpp
T* name;
T * name;
T *name;
```

Разберем создание указателя на вектор:

```cpp
std::vector * p;
```

Что происходит на этой строке?
- Компилятор выделяет память под указатель `p`, но не под объект типа `std::vector`, на который указывает `p`. Вектор может уже существовать или создаваться дальше по коду.
- Компилятор не инициализирует выделенную память, ведь мы не присвоили указателю никакого значения. Как и при [инициализации по умолчанию](/courses/cpp/chapters/cpp_chapter_0131/#block-default-initialization) других типов, не имеющих конструктора, объект `p` может содержать любой мусор. Чтобы указатель ссылался на адрес переменной, нужно этот адрес получить.

Напишите, как выглядит объявление указателя `node` на объект класса `Node`. {.task_text}

```consoleoutput {.task_source #cpp_chapter_0161_task_0060}
```
. {.task_hint}
```cpp {.task_answer}
Node * node;
```

## Оператор взятия адреса

[Оператора взятия адреса](https://en.cppreference.com/w/cpp/language/operator_member_access.html#Built-in_address-of_operator) (address-of operator) `&` — это унарный оператор, который ставится перед своим операндом и возвращает его адрес:

```cpp
bool b = true;

// Инициализируем указатель b_ptr адресом переменной b
bool * b_ptr = &b;
```


![Указатели](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-15/illustrations/cpp/pointers.jpg) {.illustration}


В данном контексте символ `&` не имеет ничего общего с объявлением ссылки или логическим «И». При объявлении ссылки символ `&` относится к типу. А при взятии адреса он ставится перед уже существующей переменной. Сравните:

```cpp
int x = 5;

int & ref = x;  // Это - объявление ссылки на x

int * ptr = &x; // А это - инициализация указателя адресом x
```

### Как вывести в консоль адрес объекта

Чтобы вывести адрес объекта в консоль, нужно явно привести его к типу указателя `void *`. 

```cpp
std::println("{}", static_cast<void *>(&x));
```
```
0x7ffe4f884814
```

Тип `void *` означает, что указатель [может ссылаться](https://timsong-cpp.github.io/cppwp/n4868/basic.compound#5) на адрес объекта любого типа. Явное приведение типа неудобно, зато подчеркивает намерение получить адрес:

```cpp
int val = 256;
int * ptr = &val;

std::println("val={}. Address: {}", val, static_cast<void *>(&val));
std::println("ptr={}", static_cast<void *>(ptr));
```
```
val=256. Address: 0x7ffe4f884814
ptr=0x7ffe4f884814
```

[Спецификатор](https://en.cppreference.com/w/cpp/utility/format/spec.html) `p` добавляется в строку форматирования, чтобы указать: в данном месте будет подставлен указатель.

```cpp
std::println("ptr={:p}", static_cast<void *>(ptr));
```
```
ptr=0x7ffd6df3c614
```

А чтобы вывести адрес в верхнем регистре, используется спецификатор `P`.

```cpp
std::println("ptr={:P}", static_cast<void *>(ptr));
```
```
ptr=0X7FFDA8185ED4
```

Реализуйте функцию `check_eq()`, которая принимает _по ссылке_ два параметра типа `double`. {.task_text}

Функция возвращает строку. Строка содержит один либо два разделенных пробелом адреса в зависимости от того, являются ли аргументы функции одним и тем же объектом в памяти. {.task_text}

Например, если первый аргумент расположен по адресу `0x7ffce00d8bc0`, а второй — по адресу `0x7ffce00d8bb8`, то функция должна вернуть строку `"0x7ffce00d8bc0 0x7ffce00d8bb8"`. {.task_text}

Для форматирования строки вам понадобится функция [std::format()](https://en.cppreference.com/w/cpp/utility/format/format.html).

```cpp {.task_source #cpp_chapter_0161_task_0070}
// Ваша реализация check_eq()
```
. {.task_hint}
```cpp {.task_answer}
std::string check_eq(double & a, double & b)
{
    return &a == &b ?
        std::format("{:p}", static_cast<void *>(&a)) :
        std::format("{:p} {:p}", static_cast<void *>(&a), static_cast<void *>(&b));
}
```

## Оператор разыменования

Чтобы обратиться к переменной, на которую ссылается указатель, перед ним ставится [оператор разыменования](https://en.cppreference.com/w/cpp/language/operator_member_access.html#Built-in_indirection_operator) (dereference operator) `*`. Он также известен как оператор косвенного доступа (indirection operator).

```cpp
int x = 504;
int * x_ptr = &x;

// Через указатель x_ptr косвенно обращаемся к x
std::println("{}", *x_ptr);
```
```
504
```

Применение оператора `*` к указателю называется **разыменованием указателя.** Так, `*x_ptr` читается как «разыменование указателя `x_ptr`» или «обращение по указателю `x_ptr`».

Указатель типа `void *` нельзя разыменовывать: компилятору неизвестно, на переменную какого размера ссылается такой указатель, и поэтому не может корректно работать с ее значением.

Разыменование необходимо и для чтения, и для _записи_ данных, адрес которых хранит указатель:

```cpp
// Изменяем значение переменной, на которую указывает x_ptr
*x_ptr = 200;
std::println("{}", x);
```
```
200
```

Что выведет этот код? {.task_text}

```cpp {.example_for_playground}
std::uint16_t code = 100;

std::uint16_t * p = &code;

*p += *p * 3;

std::println("{}", *p);
```

```consoleoutput {.task_source #cpp_chapter_0161_task_0010}
```
. {.task_hint}
```cpp {.task_answer}
400
```

В прошлой главе вы уже [реализовывали](/courses/cpp/chapters/cpp_chapter_0150/#block-swap) функцию `swap()`. На этот раз нужно написать немного странный и избыточный вариант `swap_via_pointers()`, в котором обмен значениями двух параметров происходит через указатели. {.task_text}

Для вас уже заведены два указателя. Пользуйтесь ими и временной переменной. Обращаться к параметрам `a` и `b` нельзя. {.task_text}

```cpp {.task_source #cpp_chapter_0161_task_0080}
void swap_via_pointers(double & a, double & b)
{
    double * x = &a;
    double * y = &b;

   // Ваш код. К параметрам a и b обращаться нельзя.
}
```
. {.task_hint}
```cpp {.task_answer}
void swap_via_pointers(double & a, double & b)
{
    double * x = &a;
    double * y = &b;

    double tmp = *x;
    *x = *y;
    *y = tmp;
}
```

Приоритет оператора взятия адреса `&` и оператора разыменования `*` одинаковый. Он [такой же,](https://en.cppreference.com/w/cpp/language/operator_precedence.html) как у пре-инкремента, и ниже, чем у пост-инкремента. Поэтому не забывайте правильно расставлять скобки.

```cpp
// Делаем инкремент значения, на которое указывает x_ptr
(*x_ptr)++;
std::println("{}", x);
```
```
201
```

Что выведет этот код? Введите `err` в случае ошибки компиляции. {.task_text}

```cpp {.example_for_playground}
int a = 4;
int b = *&a; // То же самое, что *(&a)
std::println("{}", b == 4);
```

```consoleoutput {.task_source #cpp_chapter_0161_task_0090}
```
. {.task_hint}
```cpp {.task_answer}
true
```

## Размер указателя

Сколько памяти выделяется под указатель? Ее должно быть достаточно, чтобы указатель мог хранить _любой_ адрес оперативной памяти. Но конкретное значение размера указателя зависит в основном от целевой ОС и архитектуры. В большинстве реализаций длина указателя равна длине [машинного слова:](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%BE) для 32-битных платформ это 4 байта, а для 64-битных — 8 байт. Есть особые случаи, когда указатель занимает больше. Про них вы узнаете позже.

Размер указателя **не зависит** от типа, на который он указывает.

Сколько байт занимает указатель в нашем [плэйграунде?](https://senjun.ru/playground/cpp/) {.task_text}

```consoleoutput {.task_source #cpp_chapter_0161_task_0020}
```
Откройте плэйграунд и примените оператор `sizeof` у указателю. {.task_hint}
```cpp {.task_answer}
8
```

Что выведет этот код? {.task_text}

```cpp
std::vector * p_vec;
bool * p_bool;

std::println("{}", sizeof(p_vec) == sizeof(b_bool));
```

```consoleoutput {.task_source #cpp_chapter_0161_task_0030}
```
Размер указателя не зависит от типа, на который он указывает. {.task_hint}
```cpp {.task_answer}
true
```

## Нулевой указатель

В отличие от ссылок, указатель не требуется инициализировать конкретным адресом. Его можно присвоить и после создания.

```cpp
std::size_t a = 16;
std::size_t b = 32;

std::size_t *  ptr;
ptr = &a;
ptr = &b;
```

Главное — помнить, что указатель, как и любая другая переменная, должен быть инициализированным:

```cpp
int * ptr; // В ptr может лежать любой мусор

std::println("{}", *ptr); // UB
```

Если указатель не ссылается на конкретный объект, обязательно присваивайте ему значение [nullptr](https://en.cppreference.com/w/cpp/language/nullptr.html). Это ключевое слово и одновременно литерал, означающий, что указатель не хранит адрес объекта:

```cpp
int * ptr = nullptr;
```

Литерал `nullptr` появился в C++11. В более старом коде вместо него используется макрос [NULL](https://cppreference.com/w/c/types/NULL.html):

```cpp
int * ptr = NULL;
```

Определение `NULL` зависит от реализации. Оно может быть таким:

```cpp
#define NULL 0
```

Или, например, таким:
```cpp
#define NULL nullptr
```

У `nullptr` тип [std::nullptr_t](https://en.cppreference.com/w/cpp/types/nullptr_t.html), а `NULL` может быть целым числом `int`. В любом случае они совместимы между собой благодаря [неявному приведению типов.](/courses/cpp/chapters/cpp_chapter_0010/#block-implicit-cast) 

```cpp
import std;

#include <cstddef> // Хедер содержит объявление макроса NULL

int main()
{
    int * ptr = nullptr;
    std::println("{}", ptr == NULL);
}
```
```
true
```

В современном C++ предпочтение отдается `nullptr`: его использование явно разграничивает, в каком случае идет работа с числами, а в каком — с указателем. 

Указатель, равный `nullptr` или `NULL`, называется **нулевым указателем.** Если указатель не хранит адрес конкретного объекта, всегда делайте его нулевым. Но помните, что разыменование нулевого указателя — это тоже UB:

```cpp
int * ptr = nullptr;

std::println("{}", *ptr); // Так делать нельзя
```

Что выведет этот код? Введите `err` в случае ошибки компиляции или `ub`, если поведение не определено. {.task_text}

```cpp {.example_for_playground}
import std;

int main()
{
    void * self = &self;
    std::println("{}", static_cast<bool>(self));
}
```

```consoleoutput {.task_source #cpp_chapter_0161_task_0050}
```
В момент инициализации `self` своим же адресом эта переменная [уже существует,](https://timsong-cpp.github.io/cppwp/std23/basic.scope.pdecl#1) поэтому ошибки компиляции нет. В `self` сохраняется ее же адрес, и он точно не равен `nullptr`. А приведение любого не нулевого числа к `bool` — это `true`. {.task_hint}
```cpp {.task_answer}
true
```

Если по логике программы указатель _может_ оказаться нулевым, перед его разыменованием добавляйте проверку на `nullptr`.

```cpp
int * ptr = nullptr;

// ...

if (ptr == nullptr)
    std::println("Null pointer");
else
    std::println("{}", *ptr);
```

Иногда проверку вида `ptr != nullptr` записывают более лаконично:

```cpp
if (ptr)
{
    // ptr == nullptr
}
else
{
    // ptr != nullptr
}
```

Этот вариант работает благодаря неявному приведению `nullptr` к `false` и остальных значений — к `true`. Однако мы рекомендуем более явную проверку вида `ptr == nullptr` и `ptr != nullptr`. Она подчеркивает, что перед вами указатель, а не `bool`, число или какой-то другой тип.


## Оператор доступа к полям и методам класса

Допуcтим, у нас есть указатель на объект класса `std::pair`:

```cpp
std::pair<std::string, bool> res = {"/", true};

std::pair<std::string, bool> * res_ptr = &res;
```

Обращение к полям объекта осуществляется через оператор `.`. Его приоритет выше, чем у оператора разыменования `*`. Но чтобы обратиться к полю объекта, нужно сначала получить к нему косвенный доступ, разыменовав указатель. Чтобы поменять порядок применения операторов, используем скобки:

```cpp
(*res_ptr).first = "/etc/search.yaml"; // обращаемся к полю

std::println("{} {}", (*res_ptr).first, (*res_ptr).second);
```
```
/etc/search.yaml true
```

Аналогичным образом выглядит вызов метода объекта:

```cpp
std::string uuid = "a674b109-b08d-433a-aed4-7e03861345d0";

std::string * p = &uuid;

std::size_t len = (*p).size(); // вызываем метод строки

std::println("{}", len);
```
```
36
```

Синтаксис вида `(*p).field` слишком громоздкий. Удобнее использовать оператор `->` для косвенного доступа к полю или методу класса через указатель. Считайте `p->field` синтаксическим сахаром, по сути не отличающимся от `(*p).field`.

```cpp
res_ptr->first = "/etc/search.yaml"; // обращаемся к полю
```

```cpp
std::size_t len = p->size(); // вызываем метод строки
```

### Указатели и рекурсивные структуры данных

Итак, через указатели мы можем работать с объектами классов и структур. А они в свою очередь могут иметь поля с типом «указатель». Если тип такого поля совпадает с типом исходного класса, то перед вами рекурсивная структура данных.

Например, так выглядит структура, реализующая элемент односвязного списка, хранящего целые числа:

```cpp
struct ListNode
{
    // Конструкторы
    ListNode(int value) : val(value) {}
    ListNode(int value, ListNode * next_node) : val(value), next(next_node) {}
    
    // Значение элемента списка
    int val = 0;
    
    // Указатель на следующий элемент списка
    ListNode * next = nullptr;
};
```

Нам даже не обязательно заводить класс `List`. Структуры `ListNode` достаточно, чтобы собрать список и работать с ним:

```cpp
// Составляем список из 3-х элементов
ListNode tail{5, nullptr};
ListNode middle{3, &tail};
ListNode head{1, &middle};

// Итерируемся по списку
for(ListNode * node = &head; node != nullptr; node = node->next)
    std::println("Node value: {}", node->val);
```
```
Node value: 1
Node value: 3
Node value: 5
```

Заведите структуру `BinTreeNode`, представляющую собой узел бинарного дерева. Она должна хранить значение `val` типа `std::size_t`, указатели на левое и правое поддерево `left` и `right`. {.task_text}

```cpp {.task_source #cpp_chapter_0161_task_0100}
// Ваша реализация BinTreeNode
```
. {.task_hint}
```cpp {.task_answer}

```

## Передача параметров по указателю

В C++ существует три способа передачи в функцию параметров:
- По значению (by value).
- По ссылке (by reference).
- По указателю (by pointer).

В прошлой главе мы [рассмотрели](/courses/cpp/chapters/cpp_chapter_0150/#block-func) передачу по значению и по ссылке. При передаче по значению функция работает с копией объекта, а при передаче по ссылке — с исходным объектом.

Как и передача по ссылке, передача по указателю нужна, чтобы избежать копирования: функция получает указатель и через него косвенно обращается к исходному объекту. Но передача по указателю означает, что он может быть равен `nullptr`. Поэтому если четко не установлено, что такого быть не может, обязательно проверяйте, является ли указатель нулевым.

```cpp
import std;

struct ConfValue
{
    std::string section;
    std::string name;
    std::string value;
};

bool is_set(ConfValue * conf_val) // Принимаем conf_val по указателю
{
    return conf_val != nullptr && !conf_val->value.empty();
}

int main()
{
    ConfValue v{"net", "ip", "127.0.0.1"};
    std::println("{}", is_set(&v));    // Передаем адрес v

    ConfValue * v_ptr = &v;
    std::println("{}", is_set(v_ptr)); // Передаем указатель v_ptr

    std::println("{}", is_set(nullptr));
}
```
```
true
true
false
```

Под капотом передача параметра по ссылке и по указателю сводится к одному и тому же: в функцию попадает адрес объекта, и функция работает с этим объектом.

Напишите функцию `has_cycle()`, которая принимает указатель на первый элемент односвязного списка и определяет, есть ли в списке цикл. {.task_text}

Список содержит цикл, если есть такой узел, до которого можно _повторно_ добраться, непрерывно перебирая указатели `next`. Визуально это можно представить как цикл с петлей. {.task_text}


![Пример списка с циклом](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-16/illustrations/cpp/linked_list_with_cycle.jpg) {.illustration}

Решите эту задачу, используя `O(1)` дополнительной памяти. У вашего решения должна быть линейная сложность `O(N)`. Чтобы посмотреть алгоритм, воспользуйтесь подсказкой. {.task_text}

```cpp {.task_source #cpp_chapter_0161_task_0120}
struct ListNode
{
    ListNode(int value) : val(value) {}
    ListNode(int value, ListNode * next_node) : val(value), next(next_node) {}
    
    int val = 0;
    ListNode * next = nullptr;
};

bool has_cycle(ListNode * head)
{

}
```
. {.task_hint}
```cpp {.task_answer}

```

### Низведение массива (array to pointer decay)



## Указатели и константность

Как вы [помните,](/courses/cpp/chapters/cpp_chapter_0150/#block-const) константная ссылка и ссылка на константный объект — это одно и то же. В случае с указателями все разнообразнее. Константный указатель и указатель на константный объект — это разные вещи.

**Константный указатель** нельзя «перевесить» на другой объект, зато сам объект изменять через него можно:

```cpp
bool is_authorized = true;
bool * const p = &is_authorized; // Константный указатель

*p = false;                      // Ок
p = nullptr;                     // ошибка
```

**Указатель на константный объект** можно переназначить, но объект через него модифицировать не получится:

```cpp
bool enable_encoding = true;
const bool * p = &enable_encoding; // Указатель на константу

*p = false;                        // Ошибка
p = nullptr;                       // Ок
```

Из этого примера видно, что указатель на константный объект можно использовать для доступа к неконстантной переменной. Просто у вас не получится изменить эту переменную через такой указатель. А получить неконстантый указатель на константный объект нельзя.

И, наконец, **константный указатель на константный объект** не разрешает ни переприсваивать указатель, ни изменять объект:

```cpp
bool has_focus = true;
const bool * const p = &has_focus; // Константный указатель на константу

*p = false;                        // Ошибка
p = nullptr;                       // Ошибка
```

Правило расстановки `const` при объявлении указателей легко запомнить:
- Если константность относится к объекту, то `const` ставится слева от `*`. То есть рядом с типом объекта.
- Если константность относится к указателю, то `const` ставится справа.


![Указатели и константность](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-16/illustrations/cpp/const_pointers.jpg) {.illustration}


На какой строке кода допущена ошибка? Введите `0`, если ошибок нет и код скомпилируется. {.task_text}

```cpp
std::vector<int> v = {1, 5, 10};   // 1
std::vector<int> * const ptr = &v; // 2

v->clear();                        // 3
v = nullptr;                       // 4
```

```consoleoutput {.task_source #cpp_chapter_0161_task_0040}
```
Указатель `ptr` является константным. {.task_hint}
```cpp {.task_answer}
4
```

В промышленной разработке константные указатели встречаются довольно редко. Чаще всего используются указатели на константные объекты. Поэтому в обиходе под константными указателями понимаются именно они.

Попробуем вывести в консоль указатель, у которого есть константность.

```cpp
const int * ptr = &val;

std::println("{}", static_cast<void *>(ptr));
```
```
main.cpp:8:25: error: static_cast from 'const int *' to 'void *' is not allowed
    8 | std::println("{}", static_cast<void *>(ptr));
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~
```

Ошибка компиляции говорит о том, что нельзя привести тип `const T *` к `void *`, то есть убрать константность. Поэтому нужно правильно расставить `const` в результирующем типе `void *`:

```cpp
const int * ptr = &val;

std::println("{:p}", static_cast<const void *>(ptr));
```
```
0x7ffc36211234
```

## Когда использовать указатели, а когда — ссылки

Вот несколько простых правил, которые помогут при выборе между ссылками и указателями:
- По умолчанию [предпочитайте](https://isocpp.org/wiki/faq/references#refs-vs-ptrs) ссылки.
- Ссылка не может быть переназначена на другой объект или обнулена, а указатель — может. Если без этого не обойтись, используйте указатель.
- Используйте указатель, если под объект нужно динамически выделять память. Как это делать, вы скоро узнаете.
- В Си есть указатели и нет ссылок. Поэтому если нужно предоставить си-интерфейс для кода на другом языке, вместо ссылок вам придется использовать указатели.

----------

## Резюме
- Указатель — это переменная, хранящая адрес в оперативной памяти.
- В типе указателя должен присутствовать символ `*`. Например, `std::string *` — это указатель на строку.
- Чтобы присвоить указателю адрес переменной, к ней применяется оператор взятия адреса `&`. Например, `&val` читается как «взятие адреса `val`».
- Чтобы через указатель косвенно обратиться к переменной, перед ним ставится оператор разыменования `*`. Так, `*p` читается как «разыменование `p`».
- Константный указатель не дает переназначать указателю новый адрес, а указатель на константный объект не дает изменять объект.
