## Глава 16.2. Адресная арифметика

Итак, указатель — это переменная, хранящая адрес. И размер указателя не зависит от типа, на который он ссылается. Зачем тогда вообще сообщать компилятору об этом типе в момент объявления? Какая разница, чей адрес содержит указатель — `bool`, `long int` или `std::queue`?

Память упрощенно можно представить как массив ячеек по 1 байту. Кстати, именно поэтому нельзя завести переменную размером, например, в 3 бита или в 11 бит при условии, что байт равен 8 бит.

Допустим, у нас есть три локальных переменных размером в 1, 4 и 8 байт:


![Переменные в адресном пространстве](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-16/illustrations/cpp/pointers_and_addresses.jpg) {.illustration}


И если бы мы захотели по указателю `p` обновить значение `retry`, но компилятор имел бы неверное представление о размере этой переменной, то вместо перезаписи 1 байта мы могли бы затереть 4, 8 или больше. Мы бы повредили значения соседних переменных. А возможно, даже испортили бы значения ячеек, в которых расположен сам указатель! Эта ситуация называется **повреждением памяти** (memory corruption).

### Прибавление к указателю целого числа

Еще одна причина, по которой компилятору важно знать о типе, на который ссылается указатель — это **адресная арифметика.**  С помощью указателей можно перемещаться по памяти, и для этого к указателям применяются арифметические операции `+`, `-`  и сравнение. И работают они с учетом типа указателя.

Адресную арифметику удобнее всего разбирать на примере указателей на сишные массивы. Как вы [помните,](/courses/cpp/chapters/cpp_chapter_0142/#block-c-array-under-the-hood) элементы сишных массивов расположены друг за другом _в непрерывной области памяти._ Убедимся в этом: переберем в цикле все элементы массива и выведем их адреса.

```cpp
const std::size_t n = 5;
int arr[n] = {16, 32, 64, 128, 256};

for (std::size_t i = 0; i < n; ++i)
{
    std::println("Address: {}. arr[{}]={}",
                 static_cast<void *>(&arr[i]), i, arr[i]);
}
```
```
Address: 0x7fffcb3c3550. arr[0]=16
Address: 0x7fffcb3c3554. arr[1]=32
Address: 0x7fffcb3c3558. arr[2]=64
Address: 0x7fffcb3c355c. arr[3]=128
Address: 0x7fffcb3c3560. arr[4]=256
```

Создадим указатель `p` на целое число и установим его на нулевой элемент:

```cpp
int * p = &arr[0];
```

Вместо этой записи чаще всего используют более лаконичную:

```cpp
int * p = arr;
```

Она означает то же самое: установку указателя на адрес нулевого элемена.

А теперь начнем смещать указатель `p` по массиву. Делается это с помощью обычного инкремента, например `++p`. 

Когда к указателю прибавляется целое число, то значение указателя увеличивается на соответствующее значение, умноженное на размер типа данных указателя. Если прибавить к указателю число, не превышающее длину массива, то он будет ссылаться на один из последующих элементов. Важно следить, чтобы указатель не вышел за границы массива. Обращение по такому указателю приведет к UB.

```cpp
const std::size_t n = 5;
int arr[n] = {16, 32, 64, 128, 256};
    
int * p = &arr[0];
std::println("{}", *p);  // 16

++p;
std::println("{}", *p);  // 32

p += 2;
std::println("{}", *p);  // 128

++p;                     // Выход за пределы массива
std::println("{}", *p);  // UB
```


![Перемещение по массиву с помощью указателя](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-chapter-16/illustrations/cpp/pointer_to_array_element.jpg) {.illustration}


### Вычитание из указателя целого числа

Вычитание целых чисел из указателей работает по этой же схеме: вычитается значение, умноженное на размер типа.

```cpp
const std::size_t n = 5;
int arr[n] = {16, 32, 64, 128, 256};
    
int * p = &arr[3];
std::println("{}", *p);  // 128

p--;
std::println("{}", *p);  // 64

p -= 2;
std::println("{}", *p);  // 16

--p;                     // Выход за пределы массива
std::println("{}", *p);  // UB
```

### Вычитание указателей

Указатели можно вычитать один из другого. Для этого у них должен быть одинаковый тип и они должны ссылаться на области непрерывного участка памяти. Например, указывать на элементы одного и того же массива.

```cpp
const std::size_t n = 5;
int arr[n] = {16, 32, 64, 128, 256};

// Указатель на нулевой элемент массива:
int * p1 = arr;  // Мы могли бы написать и так: &arr[0]

int * p2 = &arr[3];

std::println("{}", p2 - p1);
```
```
3
```

Разность между указателями равна количеству объектов заданного типа между ними, а вовсе не количестсву байт! При вычитании указателей компилятор делит получившееся значение на размер типа данных. Поэтому через разность указателей на элементы массива можно определять расстояние между ними.

### Сравнение указателей

К указателям применимо сравнение операторами `>`, `>=`, `<`, `<=`, `==` и `!=`. При этом происходит сравнение адресов, на которые они указывают. Сравнение на больше-меньше имеет смысл только в случае, если указатели ссылаются на один и тот же блок памяти.
