# Глава 16.2. Динамическое выделение памяти

Как вы [помните,](/courses/cpp/chapters/cpp_chapter_0090/#block-memory) виртуальное адресное пространство процесса разбито на области.


![Упрощенное представление памяти процесса](https://raw.githubusercontent.com/senjun-team/senjun-courses/cpp-chapter-9/illustrations/cpp/process_memory.jpg) {.illustration}


В **статической памяти** расположены глобальные переменные и объекты, помеченные ключевым словом `static`.

**На стеке** живут локальные переменные и аргументы функций. Стек также называют автоматической памятью, потому что здесь временем жизни переменных управляет компилятор. С точки зрения разработчика оно регулируется автоматически.  

**На куче** расположены переменные, память под которые выделяется вручную из кода программы во время ее исполнения, то есть динамически. Поэтому кучу также называют динамической памятью. 

Время жизни переменных на куче не ограничено их областью видимости: им управляет разработчик. Переменная создается с помощью оператора [new](https://en.cppreference.com/w/cpp/language/new.html) и уничтожает оператором [delete](https://en.cppreference.com/w/cpp/language/delete.html). Работа с переменной организуется через указатель.

```cpp
int * x = new int{6000};

*x += 2;
std::println("{}", *x);

delete x;
```
```
6002
```


При вызове `new int{6000}` на куче выделяется область памяти под тип `int`. Например, 4 байта. Затем эта память инициализируется целочисленным значением 6000, и `new` возвращает на эту память указатель. Он сохраняется в переменную `x`. В момент вызова `delete` выделенная память освобождается, а указатель `x` становится висячим (dangling pointer): он перестает указывать на корректную область памяти.

При вызове `new` для типа, у которого есть конструктор, после выделения памяти вызывается конструктор. А при вызове `delete` — сначала вызывается деструктор, а потом освобождается память.

Создадим класс `Demo`, чтобы выводить в консоль стадии жизни объекта:

```cpp
class Demo
{
public:
    Demo()
    {
        std::println("Default constructor");
    }

    Demo(int a, int b)
    {
        std::println("Parameterized constructor. Args: {}, {}", a, b);
    }

    ~Demo()
    {
        std::println("Destructor");
    }

    void run()
    {
        std::println("Calling method");
    }
};
```

Заведем объект `Demo` в динамической памяти, вызовем его метод, а затем уничтожим:

```cpp
Demo * d = new Demo{8, 9};
d->run();
delete d;
```
```
Parameterized constructor. Args: 8, 9
Calling method
Destructor
```

Операторы `new` и `delete` парные:
- Если вы не вызовите `delete` для созданного на куче объекта, то получите утечку памяти. Выделенная память будет отдана ОС только при завершении программы.
- Если вы вызовите `delete` дважды, то повредите память и получите UB.

### Динамические сишные массивы

У сишного массива константная длина. Если он создан глобально или помечен как `static`, то располагается в статической области памяти. В остальных случаях такой массив живет на стеке. Статическая область памяти и стек довольно ограничены. У вас не получится создать там действительно большие объекты. Для них предназначена куча.

Есть способ превратить сишный массив в динамический и создать его на куче. Для этого используются версии операторов с квадратными скобками [new[]](https://en.cppreference.com/w/cpp/memory/new/operator_new.html) и [delete[]](https://en.cppreference.com/w/cpp/memory/new/operator_delete.html).


Так выглядит создание неинициализированного массива и его уничтожение:

```cpp
int * arr_ptr = new int[5];

// ... Заполняем массив, работаем с ним

delete[] arr_ptr;
```

Чтобы инициализировать массив, в фигурных скобках приводятся его значения:

```cpp
double * arr_ptr = new double[3]{1.0, 2.2, 7.8};
```



## Указатели на указатели

## Возврат значения по указателю

