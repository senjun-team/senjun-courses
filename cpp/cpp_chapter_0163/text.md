# Глава 16.3. Динамическое выделение памяти

Как вы [помните,](/courses/cpp/chapters/cpp_chapter_0090/#block-memory) виртуальное адресное пространство процесса разбито на секции.


![Упрощенное представление памяти процесса](https://raw.githubusercontent.com/senjun-team/senjun-courses/cpp-chapter-9/illustrations/cpp/process_memory.jpg) {.illustration}


Переменные могут располагаться в одной из трех областей:
- **Статическая память** содержит переменные со статическим временем жизни. Это глобальные переменные и объекты, помеченные ключевым словом `static`.
- **Автоматическая память** (стек) хранит локальные переменные и аргументы функций. Их временем жизни управляет компилятор. С точки зрения разработчика оно регулируется автоматически.
- **Динамическая память** (куча, heap) содержит переменные, память под которые выделяется вручную из кода программы. Происходит это во время исполнения, то есть динамически.

Статическая и автоматическая области памяти имеют крайне ограниченный размер. Под статическую память процесса как правило выделяется 2 Кб, а под автоматическую — 2 Мб. У вас не получится завести там _действительно_ большие объекты. Для них предназначена динамическая память.

Почему же тогда работает заполнение стандартных контейнеров десятками миллионов элементов? Когда вы внутри функции заводите вектор, переменная типа `std::vector` размещается в автоматической памяти (на стеке). Но у вектора есть приватное поле — указатель на кусок динамической памяти. Там и живут элементы вектора. Получается, что объект вектора со всеми полями находится на стеке. Но одно из полей ссылается на динамическую память. И управление этой памятью реализовано в методах вектора.

Чтобы управлять выделением и освобождением динамической памяти, в языке предусмотрены парные операторы:
- `new` и `delete` для объектов.
- `new[]` и `delete[]` для массивов.

## Операторы new и delete

Временем жизни переменных в динамической памяти управляет разработчик. Оно _не ограничено_ областью видимости. Переменная создается с помощью оператора [new](https://en.cppreference.com/w/cpp/language/new.html) и уничтожает оператором [delete](https://en.cppreference.com/w/cpp/language/delete.html). Работа с переменной организуется через указатель.

```cpp
int * x = new int{6000};

*x += 2;
std::println("{}", *x);

delete x;
```
```
6002
```

При выполнении выражения `int * x = new int{6000}` происходит следующее:
1. На куче выделяется память под тип `int`. Например, 4 байта. 
2. Она инициализируется целочисленным значением `6000`.
3. Оператор `new` возвращает указатель на эту память.
4. Указатель сохраняется в переменную `x`.

В момент вызова `delete x` выделенная память помечается свободной, а указатель `x` становится висячим (dangling pointer): он перестает указывать на корректную область памяти. В любой момент по этому адресу может быть создана другая переменная.

Если у типа есть конструктор, то он срабатывает при вызове `new` сразу после выделения памяти. При вызове `delete` сначала вызывается деструктор, а потом освобождается память.

Создадим класс `Demo`, чтобы посмотреть в консоли стадии жизни объекта:

```cpp
class Demo
{
public:
    Demo()
    {
        std::println("Default constructor");
    }

    Demo(int a, int b)
    {
        std::println("Parameterized constructor. Args: {}, {}", a, b);
    }

    ~Demo()
    {
        std::println("Destructor");
    }

    void run()
    {
        std::println("Calling method");
    }
};
```

Заведем объект `Demo` в динамической памяти, вызовем его метод, а затем уничтожим:

```cpp
int main()
{
    Demo * d = new Demo{8, 9};
    d->run();
    delete d;
    std::println("Exiting main");
}
```
```
Parameterized constructor. Args: 8, 9
Calling method
Destructor
Exiting main
```

Обратите внимание, что разрушение объекта произошло до вывода строки `"Exiting main"`. 

Операторы `new` и `delete` парные. На один вызов `new` должен приходиться строго один вызов `delete`:
- Если вы _не вызовите_ `delete` для созданного через `new` объекта, то получите **утечку памяти.** Выделенная память будет возвращена ОС только при завершении программы.
- Если вы вызовите `delete` _дважды,_ то получите **двойное освобождение памяти.** Это повреждение памяти, которое может привести к произвольным последствиям. Иными словами, это типичное UB.

## Операторы new[] и delete[]

У сишного массива константная длина. Если он создан глобально или помечен как `static`, то располагается в статической области памяти. В остальных случаях такой массив живет в автоматической памяти.

Есть способ превратить сишный массив в динамический и создать его на куче. Для этого используются версии операторов с квадратными скобками [new[]](https://en.cppreference.com/w/cpp/memory/new/operator_new.html) и [delete[]](https://en.cppreference.com/w/cpp/memory/new/operator_delete.html).

Так выглядит создание неинициализированного массива и его уничтожение:

```cpp
int n = 5;
int * arr = new int[n];

// ... Заполняем массив, работаем с ним

delete[] arr;
```

В квадратные скобки конструкции `new T[n]` может быть передано любое целое положительное число. Оно не обязано быть константой. Квадратные скобки `delete[]` всегда пусты.

Чтобы инициализировать массив, в фигурных скобках приводятся его значения:

```cpp
double * arr = new double[3]{1.0, 2.2, 7.8};

delete[] arr;
```

Теперь у нас есть все необходимое, чтобы реализовать неэффективную, но работоспособную реализацию вектора. Сначала опишем конструкторы, деструктор и приватные поля. Потом добавим несколько самых интересных методов.

```cpp
class Vector
{
public:
    // Конструктор по умолчанию
    Vector() { }

    // Параметризованный конструктор
    Vector(std::size_t n, int val) :
    m_size{n}, m_capacity{n}, m_elements{new int[n]}
    {
        for (std::size_t i = 0; i < m_size; ++i)
            m_elements[i] = val;
    }

    // Деструктор
    ~Vector()
    {
        delete[] m_elements;
    }

private:
    // Реальное количество элементов 
    std::size_t m_size = 0;

    // Емкность: сколько элементов выделена память
    std::size_t m_capacity = 0;

    // Указатель на сишный массив, в котором будем
    // держать элементы
    int * m_elements = nullptr;
};
```

Мы завели перегрузку конструктора, позволяющую создавать вектор из `n` элементов со значением `val`:

```cpp
Vector v{5, 9};
```

Добавим метод `at()`. Он принимает индекс элемента и возвращает на него ссылку.

```cpp
class Vector
{
public:
    Vector();
    Vector(std::size_t n, int val);
    ~Vector();

    // Объявление
    int & at(std::size_t i);

private:
    std::size_t m_size = 0;
    std::size_t m_capacity = 0;
    int * m_elements = nullptr;
};

// ... Определения конструкторов и деструкторов

int & Vector::at(std::size_t i)
{
    if (i >= m_size)
    {
        throw std::out_of_range(
            std::format("Index {} is out of bounds. Vector size: {}",
            i, m_sizee));
    }

    return m_elements[i];
}
```


## Указатели на указатели

## Возврат значения по указателю