## Подсказка

## Организация класса BrainfuckInterpreter

Полем класса удобно сделать словарь, хранящий индексы парных скобок:

```cpp
std::unordered_map<std::size_t, std::size_t> bracket_pairs;
```

Парсинг скобок лучше вынести в отдельный метод. Он нужен для прохода по исходному коду для заполнения словаря `bracket_pairs`.

```cpp
void parse_brackets(std::string source) { /* ... */ }
```

Память из 30'000 ячеек скорее всего окажется просто переменной внутри метода, в котором организован второй проход по коду:

```cpp
std::array<unsigned char, 30'000> mem;
```

## Выполнение кода

После заполнения словаря `bracket_pairs` начинается самое интересное: выполнение кода на Brainfuck. Команды обрабатываются поштучно, одна за другой.

Но вначале создается массив с памятью `mem` и указатель на ячейку памяти `i`, равный нулю. Также нужен счетчик `i_command`, указывающий на текущую обрабатываемую команду. Так как в коде могут присутствовать скобки, то счетчик будет не только расти, но и уменьшаться:

```cpp
std::size_t i_command = 0;

while (i_command < source.size())
{
    // Обработка команд, обновление i_command
}
```

Для обработки текущей команды подойдет `switch-case`:

```cpp
while (i_command < source.size())
{
    switch (source[i_command])
    {
        case ',':
            mem[i] = std::getchar();
            break;

        /* ... */
    }

    ++i_command;
}

```

Самое сложное — это правильная обработка скобок `[` и `]`.

Получение скобки `[` означает, что нужно проверить: вдруг пора выйти из цикла? Цикл прерывается, если значение `mem[i]` равно нулю. Для этого необходимо переместиться за закрывающую скобку цикла: `i_command = bracket_pairs[i_command]`. Получение скобки `]` означает, что нужно проверить: заходить ли на очередную итерацию цикла? Если значение `mem[i]` не равно нулю, то мы перемещаемся в начало цикла: ``i_command = bracket_pairs[i_command]`.

В обоих случаях `i_command` устанавливается ровно на индекс скобки, а инкремент происходит после `switch`. Это видно в примере кода выше.

