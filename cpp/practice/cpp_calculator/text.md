# Практика. Калькулятор алгебраических выражений

## Описание проекта

Необходимо реализовать функцию `calc()`:

```cpp
double calc(const std::string & expr);
```

Функция принимает строку, которая содержит алгебраическое выражение. Оно состоит из чисел, символов математических операций и скобок. Например:

```
81.0-(2.5+1)/3
```

Функция возвращает результат вычисленного выражения. Либо бросает исключение типа [std::invalid_argument](https://en.cppreference.com/w/cpp/error/invalid_argument.html), если выражение составлено некорректно. Считаем, что входных данных, приводящих к делению на ноль, не будет.

Если в числе есть дробная часть, то она отделяется точкой: `71.45`. Допустимы числа с опущенной целой или дробной частью: `.5`, `22.`. В таких случаях опущенная часть считается равной нулю.

Математическими операциями могут быть: сумма `+`, разность `-`, произведение `*`, деление `/`.

Приоритет операций умножения и деления выше, чем сложения и вычитания.

Все перечисленные операции [левоассоциативны:](https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D1%91%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B9) при отсутствии скобок выражение с операциями одинакового приоритета вычисляется слева направо. Если бы среди операций были правоассоциативные, это бы усложнило код решения.

## Примеры

Корректно составленное выражение:

```
(1-2.8)*3
```

Значение функции `calc()`:

```
-5.4
```

Выражение с пропущенной закрывающей скобкой:

```
(16/2*3
```

Выражение с недопустимыми символами (пробелами, буквами `a` и `b`):

```
5*a + b
```

Выражение с нарушенной последовательностью математических операций:

```
10++2
```

Выражение, в котором неправильно записаны числа:

```
1.2.3-..5
```

Выражения, в которых `+` и `-` означают знак числа, нашм калькулятором не поддерживаются: 

```
-2
```

Так как в этих пяти выражениях есть ошибки, функция `calc()` для них бросает исключение `std::invalid_argument`.

## Тестирование

Вы можете дописать свои варианты алгебраических выражений в `main.cpp` и проверить, как ведёт себя функция `calc()` на различных входных данных. Для этого нажмите кнопку «Запустить».

Когда функция `calc()` будет готова к тестированию, нажмите кнопку «Отправить на проверку». По ней запустятся юнит-тесты из файла `tests.cpp`. В этом же файле можно посмотреть ожидаемые значения функции для набора разных выражений.

## Что может пригодиться

Чтобы проверить, что символ является числом, вам поможет функция [std::isdigit()](https://en.cppreference.com/w/cpp/string/byte/isdigit.html).

Если вместо операторов C++ `*`, `/`, `-` и `+` вам удобнее будет использовать функции, то вовсе не обязательно писать их самостоятельно:

```cpp
// Так делать не надо
double sum(double a, double b)
{
    return a + b;
}
```

Вы можете воспользоваться [функциями](https://en.cppreference.com/w/cpp/header/functional.html#Arithmetic_operations) стандартной библиотеки:
- `std::plus`
- `std::minus`
- `std::multiplies`
- `std::divides`

## Теория

Калькулятор алгебраических выражений — классическое задание, которое дают студентам, обучающимся программированию. Поэтому если вы знаете, как выполнить проект, можете пропустить этот раздел. Здесь будет рассмотрен один из подходов к решению.

## Алгоритм вычисления выражения

Декомпозируем вычисление алгебраического выражения на три подзадачи:
- токенизация,
- перевод в постфиксную форму,
- вычисление выражения в постфиксной форме.

### 1. Токенизация

**Токенизация** — это лексический анализ строки, то есть разбиение её на токены. В контексте нашей задачи токен — это неделимая составляющая арифметического выражения: математическая операция, число (операнд), скобка.

Входные данные для токенизации — строка с выражением. Например:

```
9.5-(1+3)
```

На выходе — список токенов:

```
┌───────┐┌────────┐┌───────┐┌───────┐┌────────┐┌───────┐┌───────┐
│  9.5  ││    -   ││   (   ││  1    ││    +   ││   3   ││  )    │ 
└───────┘└────────┘└───────┘└───────┘└────────┘└───────┘└───────┘
 число    операция  скобка   число    операция  число    скобка
```

Токенизацию строки удобно проводить с помощью конечного автомата (КА). Упрощённо он [описывается](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82) как устройство, принимающее ограниченное число состояний. КА читает по одному символу за раз некую входную последовательность. В зависимости от текущего состояния и прочитанного символа КА меняет своё состояние. При переходе между состояниями он может выполнять дополнительную работу.

КА незаменим в случаях, когда требуется удобно и гибко описать последовательность обработки входных данных, переход между состояниями и выполнение при этом каких-то действий.

Составим КА для токенизации арифметического выражения. Его входная последовательность — это строка из цифр, точки и символов `+`, `-`, `*`, `/`, `(`, `)`. Любой другой символ будем считать ошибочным. 

Возможные состояния КА: начало работы; прочитан односимвольный токен; накапливается целая часть числа; накапливается дробная часть числа; произошла ошибка. Односимвольный токен — это скобка либо математическая операция.

Опишем этот КА таблицей переходов:

| Текущее состояние                  | Прочитанный символ | Новое состояние                    |
| ---------------------------------- | ------------------ | ---------------------------------- |
| Начало работы                      |  Цифра             | Накапливается целая часть числа    |
|                                    |  Точка             | Накапливается дробная часть числа  |
|                                    |  Операция          | Прочитан односимвольный токен      |
|                                    |  Скобка            | Прочитан односимвольный токен      |
|                                    |  Другой            | Ошибка                             |
| Прочитан односимвольный токен      |  Цифра             | Накапливается целая часть числа    |
|                                    |  Точка             | Накапливается дробная часть числа  |
|                                    |  Операция          | Прочитан односимвольный токен      |
|                                    |  Скобка            | Прочитан односимвольный токен      |
|                                    |  Другой            | Ошибка                             |
| Накапливается целая часть числа    |  Цифра             | Накапливается целая часть числа    |
|                                    |  Точка             | Накапливается дробная часть числа  |
|                                    |  Операция          | Прочитан односимвольный токен      |
|                                    |  Скобка            | Прочитан односимвольный токен      |
|                                    |  Другой            | Ошибка                             |
| Накапливается дробная часть числа  |  Цифра             | Накапливается дробная часть числа  |
|                                    |  Точка             | Ошибка                             |
|                                    |  Операция          | Прочитан односимвольный токен      |
|                                    |  Скобка            | Прочитан односимвольный токен      |
|                                    |  Другой            | Ошибка                             |

При чтении ошибочного символа КА из любого состояния переходит в состояние ошибки. При чтении точки из состояния накопления целой части числа КА переходит к накоплению дробной части. А из состояния накопления дробной части — в состояние ошибки. Потому что в записи одного числа может быть только одна точка.

Обратите внимание, что КА умеет определять только два типа ошибок, которые могут быть допущены в алгебраическом выражении: если прочитан неожиданный символ (например, буква `a`) или если в числе присутствует больше одной точки. И это абсолютно нормально: более сложные ошибки будут выявляться на следующих этапах разбора алгебраического выражения. Единственная задача КА — разбить строку на последовательность корректных токенов.

В таблицу переходов можно было бы добавить столбец «Действие» и в нём описать функции, которые должны вызываться при переходе между состояниями. Например, при переходе в состояние «Ошибка» требуется прерывать обработку токенов и бросить исключение.


### 2. Перевод инфиксной формы выражения в постфиксную

Инфиксная запись выражения означает, что математические операции идут _между_ числами, а скобки изменяют приоритет вычислений:

```
1+2
```

Алгоритмизировать вычисление выражения в инфиксной записи вполне реально. Но сделать это для постфиксной записи гораздо проще. Постфиксная запись предполагает, что в выражении сначала идут числа, а затем — операции:

```
1 2 +
```

Постфиксная форма записи также [известна как](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C) обратная бесскобочная запись или польская инверсная запись.

Входные данные для построения постфиксной формы — это набор токенов, на которые разобрано выражение в инфиксной форме. Например, выражение `9.5-(1+3)`, представленное токенами:

```
┌───────┐┌────────┐┌───────┐┌───────┐┌────────┐┌───────┐┌───────┐
│  9.5  ││    -   ││   (   ││  1    ││    +   ││   3   ││  )    │ 
└───────┘└────────┘└───────┘└───────┘└────────┘└───────┘└───────┘
 число    операция  скобка   число    операция  число    скобка
```

После перевода выражения в постфиксную форму на выходе мы получим последовательность токенов, идущих уже в другом порядке. Причём скобок среди них не будет:

```
┌───────┐┌────────┐┌───────┐┌────────┐┌────────┐
│  9.5  ││    1   ││   3   ││    +   ││    -   │
└───────┘└────────┘└───────┘└────────┘└────────┘
 число    число     число    операция  операция
```

Выражение `9.5-(1+3)` в постфиксной записи выглядит как `9.5 1 3 + -`.

Для преобразования инфиксной формы в постфиксную используется [алгоритм Дейкстры](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D0%BE%D0%B9_%D1%81%D1%82%D0%B0%D0%BD%D1%86%D0%B8%D0%B8) «Сортировочная станция». Такое название он получил из-за сходства с действиями на железнодорожных сортировочных станциях. 

У нас есть вход (список токенов), выход (тоже список токенов) и стек. И вот как выглядит алгоритм применительно к нашей задаче, то есть для алгебраических выражений, в которых допустимы только бинарные левоассоциативные операции.

**Шаг 1.** В цикле проходим по токенам: 

— Если токен — число, добавляем его к выходному списку токенов.

— Если токен — открывающая скобка, помещаем его в стек.

— Если токен — закрывающая скобка: пока верхним элементом стека не станет открывающая скобка, перекладываем из него токены в выходной список. Открывающая скобка удаляется из стека и не добавляется в выходной список. Если стек закончился и в нём не обнаружена открывающая скобка, то в алгебраическом выражении допущена ошибка: не согласованы скобки.

— Если токен — математическая операция: пока операция на вершине стека имеет больший или равный приоритет, перемещаем токены из стека в выходной список. Затем помещаем токен с данной операцией в стек.

**Шаг 2.** Когда входная последовательность токенов закончилась, выталкиваем из стека все токены в выходной список. При этом стек должен содержать только токены операций. Если это не так, то в алгебраическом выражении не согласованы скобки.

После выполнения этих двух шагов в выходном списке сформировано алгебраическое выражение в постфиксной форме.

Пример:

![Алгоритм Сортировочная станция](https://raw.githubusercontent.com/senjun-team/senjun-courses/refs/heads/cpp-practice-5/illustrations/cpp/shunting_yard_algorithm.jpg) {.illustration}

### 3. Вычисление выражения в постфиксной форме

На предыдущем этапе был получен список токенов алгебраического выражения в постфиксной форме. Осталось получить результат этого выражения. Воспользуемся [стековым алгоритмом](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C#%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BD%D0%B0_%D1%81%D1%82%D0%B5%D0%BA%D0%B5) вычисления выражения в постфиксной форме.

В цикле проходим по токенам:

— Если токен — число, то он помещается в стек.

— Если токен — математическая операция, то она выполняется. Для этого извлекается необходимое количество операндов из стека, к ним применяется операция, и результат вычисления помещается в стек. Важно помнить, что значение на вершине стека — это правый операнд, а не левый.

После выполнения этого цикла в стеке должно остаться единственное значение. Это и есть результат алгебраического выражения.
