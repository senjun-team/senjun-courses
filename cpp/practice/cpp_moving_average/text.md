# Практика. Скользящее среднее

## Описание проекта

Нужно написать класс для расчета скользящего среднего в окне из `N` чисел.

### Что такое скользящее среднее

Допустим, размер окна `N` равен 3. Из внешней среды вы поштучно получаете целые числа. В любой момент времени должна быть возможность посчитать среднее арифметическое последних 3-х накопленных чисел. Это и есть скользящее среднее.

Вначале у вас нет чисел:

```
numbers = []
```

Вы получаете первое число и накапливаете его:

```
input -> 5

numbers = [5]
```

Затем получаете второе число:

```
input -> 0

numbers = [0, 5]
```

Затем — третье. В этот момент уже достаточно данных для расчета скользящего среднего:

```
input -> 1

numbers = [1, 0, 5]

moving_average = 2.0
```

Вы получаете четвертое число. Так как окно вмещает только 3 числа, первое число больше не участвует в расчетах:

```
input -> 8

numbers = [8, 1, 0]

moving_average = 3.0
```

Окно накапливаемых чисел перемещается по последовательности, отсюда и название «скользящее среднее».

### Реализация скользящего среднего

Реализуйте класс `MovingAverage`. 

В конструкторе он принимает размер окна типа `std::size_t`. Если передан 0, конструктор бросает исключение `std::invalid_argument`.

У класса есть три публичных метода: для получения размера окна, добавления нового числа и расчета скользящего среднего.

Метод `window_size()` возвращает заданный в конструкторе размер окна.

Метод `add()` принимает новое число типа `int` и ничего не возвращает. Он нужен для накопления чисел в окне.

Метод `val()` возвращает значение скользящего среднего типа `double`. Если в момент вызова не накоплено нужное количество чисел, метод возвращает константу `NAN` — not a number, [нечисло](https://en.cppreference.com/w/c/numeric/math/NAN). Вы уже использовали ее [в главе про условия.](/courses/cpp/chapters/cpp_chapter_0030/#block-nan)

Подумайте, какой из контейнеров или адаптеров подойдет лучше всего для накопления чисел в окне.

Необходимо, чтобы методы `add()` и `val()` работали за константное время `O(1)`.

Пример работы с объектом класса:

```c++
MovingAverage ma = MovingAverage(2);

ma.add(-5);
ma.add(4);

double x = ma.val(); // -0.5

std::size_t n = ma.window_size(); // 2
```

### Приведение типов при делении

При выполнении этой практики вам потребуется делить одно целое число на другое, чтобы получить `double`. 

В C++ результат деления одного целого на другое — это тоже целое:

```c++
int a = 10;
std::size_t b = 6;
std::print("{}", a / b); // 1
```

Чтобы вместо целого получить результат с плавающей точкой, нужно, чтобы хотя бы одно из участвующих в делении чисел было типа `double`. Для этого выполните явное приведение типа с помощью вызова [static_cast()](https://en.cppreference.com/w/cpp/language/static_cast). Синтаксис:

```
static_cast<целевой тип>(выражение)
```

```c++
int a = 10;
std::size_t b = 6;
std::print("{}", static_cast<double>(a) / b); // 1.6667
```

## Тестирование

По кнопке **«Запустить»** компилируется и запускается `main.cpp`. Внутри `main()` вы можете дописать свои сценарии работы с классом `MovingAverage`.

По кнопке **«Отправить на проверку»** выполняются юнит-тесты из файла `tests.cpp`. Запустите их, когда класс `MovingAverage` будет готов к тестированию. В `tests.cpp` можно посмотреть ожидаемое поведение класса для различных сценариев.

Проект будет засчитан как выполненный после успешного прохождения юнит-тестов.

Если у вас возникнут проблемы при выполнении практики, воспользуйтесь подсказкой. Она доступна по кнопке со знаком вопроса.
