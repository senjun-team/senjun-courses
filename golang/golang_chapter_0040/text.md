# Глава 4 
## Массивы

Массив — это структура данных, которая хранит упорядоченный набор однотипных элементов. Вот, как можно объявить и инициализировать массив, в котором находятся пять целых чисел: 

```golang
arr := [5]int{1, 2, 3, 4, 5} 
```

Длина массива — это часть типа массива. Так `arr` из примера выше имеет тип `[5]int`.

`[5]int` в памяти компьютера — это всего лишь пять целочисленных значений, расположенных последовательно. Массивы в `Go` - это последовательность значений. Переменная массива означает весь массив, а не указатель на первый элемент, на, например, в языке `C`. Это означает, что когда вы передаете массив в функцию, то передается копия всего массива, а не указатель на него. Такого поведения можно избежать, создав указатель на массив и передав его в качестве аргумента. 

Необязательно писать количество элементов массива `[5]int`, можно использовать следующую запись:

```golang
arr := [...]int{1, 2, 3, 4, 5} 
```
В этом случае компилятор сам посчитает количество элементов. Тип массива `arr` от этого не поменяется, и будет по-прежнему `[5]int`.

Можно инициализировать лишь первые несколько элементов, тогда оставшиеся получат значение по умолчанию:

```golang
arr := [10]int{1, 2, 3, 4, 5}
```

Массив в этом случае содержит следующие элементы: 

```
[1 2 3 4 5 0 0 0 0 0]
```

Если нет необходимости инициализировать массив конкретными значениями, то можно объявить его следующим образом: 

```golang
var arr [5]int 
```
Тогда каждому элементу массива будет присвоено значение по умолчанию для этого типа.

Узнать длину массива можно с помощью функции `len()`:

```golang
fmt.Println(len(arr))
```

Индексация элементов массива начинается с нуля, т.е. в примере ниже элемент с индексом `0` массива `arr` равен `1`. Элемент с индексом `4` равен `5`. Длина массива `arr` равна `5`.

```golang
arr := [5]int{1, 2, 3, 4, 5} 
```

Чтобы обратиться к элементу массива с индексом `i`, достаточно поставить после имени массива квадратные скобки с этим индексом `[i]`. Например:

```golang
arr[3] = 250 
``` 

Можно инициализировать конкретные элементы массива по их индексу:

```golang 
arr := [10]int{4: 100, 7: 400}
```

Массив в этом случае содержит следующие элементы:

```
[0 0 0 0 100 0 0 400 0 0]
```

Простое число — это натуральное число, которое больше `1` и делится только на себя и на `1`. Напишите программу, которая заполнит массив из `100` элементов первыми `100` простыми числами. Выведите полученный массив на экран. {.task_text}

```golang {.task_source #golang_chapter_0040_task_0010}
package main
import "fmt"

func main() {
	// ваш код здесь
}
```  

Проверяйте на простоту все числа подряд и добавляйте простые в массив до тех пор, пока не заполните его. {.task_hint}

``` golang {.task_answer}
package main

import "fmt"

func main() {
	var arr [100]int

	i := 0      // индекс простого числа
	number := 2 // число

	for i < 100 {
		isPrime := true

		for j := 2; j < number; j++ {
			if number%j == 0 {
				isPrime = false
                break
			}
		}

		if isPrime {
			arr[i] = number
			i++
		}

		number++
	}

	fmt.Println(arr)
}
```

Для обхода массива необязательно заводить переменную-счетчик и проверять ее на равенство длине массива. Для этих целей можно воспользоваться ключевым словом `range`. Например: 

```golang 
arr := [3]string{"С", "Oberon", "Pascal"}

for key, val := range arr {
    fmt.Println(key, ": ", val)
}
```

```
0 :  С
1 :  Oberon
2 :  Pascal
```

Ключевое слово `range` возвращает два аргумента: ключ `key` и значение `val`. В данном случае ключ представляет собой индекс элемента массива, а `val` — значение элемента массива.

В `Go`, если какая-либо из возвращаемых переменных не нужна, можно поставить пустой идентификатор `_`. Например:

```golang 
arr := [3]string{"С", "Oberon", "Pascal"}

for _, val := range arr {
    fmt.Println(val)
}
```

```
С
Oberon
Pascal
```
Массивы могут быть многомерными. Вот, как можно объявить двумерный массив (таблицу) из чисел типа `int` и задать элементу этой таблицы с индексами `4`, `5` значение `250`:

```golang
var arr [10][10]int

arr[4][5] = 250
```

На практике обычно используется одномерные и двумерные массивы, в исключительных случаях — трехмерные. Использовать массивы большей размерности, без веских на то причин, не рекомендуется. Это усложняет программный код и чревато ошибками. 

Объявите двумерный массив типа `int` размерностью `10x10` и задайте каждому его элементу значение, равное сумме индексов этого элемента. Например, для элемента с индексами `4` и `5` значение будет равно `4 + 5 = 9`. Выведите полученный массив в виде таблицы на экран, отделяя значения друг от друга символом табуляции `\t`. Последний элемент каждой строки таблицы символа табуляции содержать не должен. {.task_text}

```golang {.task_source #golang_chapter_0040_task_0020}
package main
import "fmt"

func main() {
	// ваш код здесь
}
```  

Чтобы пройти по всем элементам двумерного массива, необходимо написать цикл в цикле. Внешний цикл осуществляет проход по строкам, внутренний - по столбцам. {.task_hint}

``` golang {.task_answer}
package main

import (
	"fmt"
)

func main() {
    var arr [10][10]int

    for i := 0; i < 10; i++ {
		for j := 0; j < 10; j++ {
			arr[i][j] = i + j
			if j == 9 {
				fmt.Print(arr[i][j])
			} else {
				fmt.Print(arr[i][j], "\t")
			}
		}
		fmt.Println()
	}
}
```

Верхняя треугольная матрица (таблица) — матрица, у которой все элементы, стоящие ниже главной диагонали, равны нулю. Главная диагональ — набор элементов матрицы, взятый по диагонали от верхнего левого угла в направлении правого нижнего, т.е. таких элементов, для которых равны номер строки и номер столбца. Объявите двумерный массив типа `int` размерностью `10x10` и задайте его элементам такие значения, чтобы получилась верхняя треугольная матрица. Каждому ненулевому элементу этой матрицы задайте значение, равное сумме номеров этого элемента. Учтите, что номера матрицы в линейной алгебре принято считать с единицы, это нужно иметь в виду при вычислении суммы. Так, элемент в коде с индексами `[3][1]` должен быть равен `6`, потому что в линейной алгебре этот элемент имеет номера `[4][2]`.  Выведите полученный массив в виде таблицы на экран, отделяя значения друг от друга символом табуляции `\t`. Последний элемент каждой строки таблицы символа табуляции содержать не должен. {.task_text}

```golang {.task_source #golang_chapter_0040_task_0030}
package main
import "fmt"

func main() {
	// ваш код здесь
}
```  

Если `i > j`, где `i` - индекс строки, а `j` - индекс столбца, то элемент находится ниже главной диагонали. {.task_hint}

``` golang {.task_answer}
package main

import "fmt"

func main() {
	var arr [10][10]int

	for i := 0; i < 10; i++ {
		for j := 0; j < 10; j++ {
			arr[i][j] = i + j + 2
			if i > j {
				arr[i][j] = 0
			}
			if j == 9 {
				fmt.Print(arr[i][j])
			} else {
				fmt.Print(arr[i][j], "\t")
			}
		}
		fmt.Println()
	}
}
```

Напоследок заметим, что массивы имеют множество недостатков. Вот некоторые из них:
- после того, как массив определен, вы не можете изменить его размер;
- передавая массив функции в качестве параметра, вы на самом деле передаете его копию, поэтому изменения внутри массива по выходу из этой функции будут потеряны;
- передача массива в функцию всегда выполняется медленно, поскольку каждый раз создается копия этого массива. 

Конечно, можно передать массив в функцию по указателю. Однако тип такого указателя зависит от размера массива, поскольку размер массива — часть его типа. Делать подобное неудобно.

Этих недостатков лишены срезы, о которых пойдет речь в следующей главе. 

## Резюме 
1. В `Go` используются массивы, которые могут быть как одномерными, так и многомерными.
2. Для обхода массива можно использовать ключевое слово `range`. 
3. Массивы обладают множеством недостатков, которых лишены срезы, поэтому массивы в `Go` используются достаточно редко. 