# Глава 16. Горутины и каналы 

## Понятие горутины

В Go программа исполняется как одна или несколько горутин. **Горутина** — это легковесный поток, который управляется средой выполнения Go. Функция `main` также выполняется в горутине. До сих пор все наши программы выполнялись в единственной горутине. 

Чтобы запустить из `main` новую горутину, достаточно поставить перед вызовом функции ключевое слово `go`. В следующем примере мы запускаем горутину для вывода сообщения о загрузке. В это время, в функции `main`, параллельно выполняется некоторая работа. Когда эта работа закончится, функция `main` завершится. Вместе с ней остановятся и все горутины, которые были запущены из `main`:

```go {.example_for_playground}
package main

import (
	"fmt"
	"time"
)

func printLoad(seconds time.Duration) {
	const pointsNumber = 10
	millisconds := seconds * 1000
	msPerPoint := (millisconds / pointsNumber)
	fmt.Print("Loading")
	for range pointsNumber {
		time.Sleep(msPerPoint * time.Millisecond)
		fmt.Print(".")
	}
}

func main() {
	go printLoad(5)
	// тяжелая задача
	time.Sleep(3 * time.Second)
	fmt.Println("\nDone")
}
```
```
Loading.....
Done
```

Если `main` закончится раньше горутины, которая была из нее вызвана, то эта горутина не успеет завершиться:

```go {.example_for_playground}
package main

import (
	"fmt"
	"time"
)

func printLoad(seconds time.Duration) {
	const pointsNumber = 10
	millisconds := seconds * 1000
	msPerPoint := (millisconds / pointsNumber)
	fmt.Print("Loading")
	for range pointsNumber {
		time.Sleep(msPerPoint * time.Millisecond)
		fmt.Print(".")
	}
}

func main() {
	// тяжелая задача
	go func() {
		time.Sleep(5 * time.Second)
		fmt.Println("\nDone")
	}()
	printLoad(3)
}
```
```
Loading..........
```

Если в горутине возникнет паника, то горутина немедленно завершится вместе с программой:

```go {.example_for_playground}
package main

import (
	"fmt"
	"time"
)

func printLoad(seconds time.Duration) {
	const pointsNumber = 10
	millisconds := seconds * 1000
	msPerPoint := (millisconds / pointsNumber)
	fmt.Print("Loading")
	for range pointsNumber {
		time.Sleep(msPerPoint * time.Millisecond)
		fmt.Print(".")
		panic("failed to load next symbol")
	}
}

func main() {
	go printLoad(5)
	// тяжелая задача
	time.Sleep(3 * time.Second)
	fmt.Println("\nDone")
}
```
```
Loading.
panic: failed to load next symbol
```

Не поможет даже восстановление из вызывающей горутины: 

```go {.example_for_playground}
package main

import (
	"fmt"
	"time"
)

func printLoad(seconds time.Duration) {
	const pointsNumber = 10
	millisconds := seconds * 1000
	msPerPoint := (millisconds / pointsNumber)
	fmt.Print("Loading")
	for range pointsNumber {
		time.Sleep(msPerPoint * time.Millisecond)
		fmt.Print(".")
		panic("failed to load next symbol")
	}
}

func main() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("\nRecovered: %v\n", r)
		}
	}()
	go printLoad(5)
	// тяжелая задача
	time.Sleep(3 * time.Second)
	fmt.Println("\nDone")
}
```
```
Loading.
panic: failed to load next symbol
```

Восстановление работает только в самой горутине, которая вызывает панику: 

```go {.example_for_playground}
package main

import (
	"fmt"
	"time"
)

func printLoad(seconds time.Duration) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("\nRecovered: %v\n", r)
		}
	}()
	const pointsNumber = 10
	millisconds := seconds * 1000
	msPerPoint := (millisconds / pointsNumber)
	fmt.Print("Loading")
	for range pointsNumber {
		time.Sleep(msPerPoint * time.Millisecond)
		fmt.Print(".")
		panic("failed to load next symbol")
	}
}

func main() {
	go printLoad(5)
	// тяжелая задача
	time.Sleep(3 * time.Second)
	fmt.Println("\nDone")
}
```
```
Loading.
Recovered: failed to load next symbol

Done
```

## Горутины изнутри

Как уже было сказано, горутина — легковесный поток, но все же горутина — это не то же самое, что поток операционной системы.

Поток операционной системы содержит стек. Стек хранит локальные переменные вызовов функций. Он имеет фиксированный размер. Как правило, 2 Мбайта. Этот размер оказывается большим для потоков, которые нужны, например, чтобы показывать надпись загрузки. Однако этот размер окажется маленьким для сложных функций. Например, для таких, которые обладают глубокой рекурсией. 

Горутина имеет стек переменного размера. Это повышает ее эффективность. Она начинает выполняться с небольшим стеком. Как правило, 2 Кбайта. Такой стек, аналогично стеку потока операционной системы, хранит локальные переменные вызовов функций. Он увеличивается, по мере необходимости. Его размер может достигать 1 Гбайта. 

Потоки операционной системы планируются в ее ядре. Процессор периодически прерывается по таймеру, и запускается планировщик. Планировщик приостанавливает поток, сохраняет значения его регистров в памяти и решает, какой из потоков запустить следующим. Для этого он восстанавливает регистры данного потока и возобновляет его выполнение. Все это происходит медленно, поскольку требуется многократное обращение к памяти, обладающей слабой локальностью. Слабая локальность означает, что вероятность повторного обращения к те же ячейкам памяти невелика. Вероятность обращения к ячейкам памяти, расположенным рядом, также небольшая. 

Среда выполнения Go имеет свой планировщик. Он мультиплексирует выполнение `m` горутин на `n` потоках операционной системы. Этот метод называется **m:n планирование**. Планировщик Go работает аналогично планировщику операционной системы, но его задания касаются только горутин единственной программы на Go. 

Планировщик Go вызывается не по таймеру, а неявными инструкциями языка Go. Он работает быстро, потому что у него нет необходимости обращаться к ядру операционной системы и управлять потоками.

Планировщик Go использует параметр с именем `GOMAXPROCS`. Этот параметр содержит максимальное количество потоков, которое можно использовать для одновременного запуска горутин. До Go 1.25 этот параметр равнялся количеству логических ЦП на машине. Начиная с версии Go 1.25, разработчики приняли во внимание контейнерную среду некоторых программ. Для программ в контейнере теперь [учитываются](https://go.dev/blog/container-aware-gomaxprocs) ограничения этого контейнера. Если программа на Go выполняется внутри контейнера с ограничением ресурсов ЦП, `GOMAXPROCS` по умолчанию соответствует этому ограничению. Таким образом, `GOMAXPROCS` оказывается меньше числа реальных ЦП. Иногда переменную окружения `GOMAXPROCS` устанавливают явно, либо для этого вызывают функцию [runtime.GOMAXPROCS](https://pkg.go.dev/runtime#GOMAXPROCS) из кода.

Важной особенностью горутин является то, что  они не имеют идентификатора, который может быть получен как обычное значение. Он недоступен программисту. Это было сделано разработчиками Go сознательно. В противном случае могли бы возникнуть зависимости функции не только от ее аргументов. Она могла бы зависеть и от идентификатора потока, в котором функция выполняется. Разработчики Go уверяют, что это не нужно и поощряют простоту в написании программ.

## Каналы 

Каналы дают возможность горутинам «общаться» между собой. Они позволяют одной горутине передать какое-либо значение другой горутине. Канал передает данные определенного типа — **типа элементов канала.** 

Каналы бывают **буферизованные** и **небуферизованные**. Другими словами, с буфером и без буфера. Чтобы создать небуферизованный канал, нужно воспользоваться встроенной функцией `make`. Например, для значений типа `bool`:

```go
ch := make(chan bool)
```

Следующие три инструкции демонстрируют, как писать в канал и читать из него: 

```go
ch <- true  // Записать true в канал
val := <-ch // Прочесть значение из канала в val
<-ch        // Результат чтения не используется
```

Закрывается канал через встроенную функцию `close`:

```go
close(ch)
```

Канал закрывают, если по этому каналу больше не будут передаваться значения. Закрывать канал каждый раз нет необходимости. Ресурсы недоступного канала освобождаются сборщиком мусора автоматически. Канал закрывают только тогда, когда это нужно по логике программы. Например, чтобы сообщить горутине, что все данные переданы. 

Попытка закрыть уже закрытый канал приведет к панике: 

```go {.example_for_playground}
package main

func main() {
	ch := make(chan bool)
	close(ch)
	close(ch)
}
```
```
panic: close of closed channel
```

Попытка отправить значение в закрытый канал также приведет к панике:

```go {.example_for_playground}
package main

func main() {
	ch := make(chan bool)
	close(ch)
	ch <- true
}
```
```
panic: send on closed channel
```

При чтении из закрытого небуферизованного канала вы получите значение типа по умолчанию.

Иногда нужно точно знать, получили мы реальное значение или нет. Например, при получении значения из закрытого небуферизованного канала никакого значения прочитано из него не будет. На самом деле, при чтении из канала возвращается два значения. В этом случае используют следующую конструкцию: 

```go
val, ok := <-ch
```
Если `ok` равен `true`, то значение прочитано. В противном случае — нет.

Каналы являются ссылочным типом. Они представляют собой ссылку на некоторую структуру данных. Их можно сравнивать. Если два канала ссылаются на одну и ту же структуру данных, то результат сравнения — `true`. В противном случае — `false`:

```go {.example_for_playground}
package main

import "fmt"

func main() {
	ch := make(chan bool)
	ch2 := ch
	fmt.Println(ch == ch2)
}
```
```
true
```

```go {.example_for_playground}
package main

import "fmt"

func main() {
	ch := make(chan bool)
	ch2 := make(chan bool)
	fmt.Println(ch == ch2)
}
```
```
false
```

Также допустимо сравнивать каналы с `nil`.

Небуферизованные каналы удобно использовать для синхронизации работы горутин. Пока горутина ожидает получения значения из канала, она блокируется. Аналогично блокируется отправитель, пока значение из канала не будет прочитано. Используйте эту идею для решения следующего задания. {.task_text}

Некоторая задача `task` выполняется на сервере `server`. Сервер не запущен все время. Он запускается по мере необходимости. На старт сервера затрачивается некоторое время. Для выполнения задачи нужно подготовить данные. Эта операция также выполняется не сразу. {.task_text}

Код ниже выполняется последовательно. Модифицируйте его таким образом, чтобы он работал параллельно. Данные должны готовиться во время того, как уже стартует сервер. В отладочных сообщениях вы должны увидеть следующий текст: {.task_text}

```
starting server...
task data prepared
calculating...
stopping server...
```

```go {.task_source #golang_chapter_0160_task_0010}
package main

import (
	"fmt"
	"time"
)

type deviceConfig struct {
	id   int
	name string
	job  func()
}

func main() {
	server := deviceConfig{1, "server", func() {
		fmt.Println("starting server...")
		time.Sleep(1 * time.Second)
		fmt.Println("calculating...")
		time.Sleep(1 * time.Second)
		fmt.Println("stopping srever...")
	}}
	task := deviceConfig{2, "task", func() {
		time.Sleep(2 * time.Second)
		fmt.Println("task data prepared")
	}}
	task.job()
	server.job()
}
```

Используйте небуфиризованные каналы типа `struct{}`. Передача значения в такой канал будет сигнализировать о том, что работа выполнена. Не забудьте, что `main` — это тоже горутина. Она не будет ждать выполнения всех других горутин, если не организовать такое поведение явно. {.task_hint}

```go {.task_answer}
package main

import (
	"fmt"
	"time"
)

type deviceConfig struct {
	id   int
	name string
	job  func()
}

func main() {
	dataReady := make(chan struct{})
	done := make(chan struct{})
	server := deviceConfig{1, "server", func() {
		fmt.Println("starting server...")
		time.Sleep(1 * time.Second)
		<-dataReady
		fmt.Println("calculating...")
		time.Sleep(1 * time.Second)
		fmt.Println("stopping server...")
		done <- struct{}{}
	}}
	task := deviceConfig{2, "task", func() {
		time.Sleep(2 * time.Second)
		fmt.Println("task data prepared")
		dataReady <- struct{}{}
	}}
	go task.job()
	go server.job()
	<-done
}
```

## Утечка горутин 

Важно помнить, что сборщик мусора не занимается тем, чтобы останавливать «зависшие» горутины. Вы должны сами позаботиться о том, чтобы каждая горутина успешно завершилась. В противном случае возникнет утечка памяти. 

Следующий пример демонстрирует утечку горутин. 

## Резюме

1. Горутина — это аналог потока операционной системы. Однако горутина исполняется в рантайме программы на Go. Поэтому она легче потока операционной системы.
2. Чтобы запустить новую горутину, достаточно поставить ключевое слово `go` перед вызовом функции. 
3. Горутина содержит стек переменного размера. Это позволяет эффективнее использовать ресурсы вычислительной машины.
4. Рантайм Go имеет свой планировщик, который мультиплексирует выполнение горутин на потоках операционной системы.
5. Параметр `GOMAXPROCS` отвечает за максимальное число потоков, которые могут быть использованы для одновременного запуска горутин. Есть возможность установить этот параметр вручную, но чаще всего в этом нет необходимости. Он уже равен некоторому разумному значению.
6. Горутины не имеют идентификатора.
7. Каналы позволяют горутинам передавать некоторые значения между собой. 
8. Различают буферизованные и небуферизованные каналы. Небуферизованные каналы бывают полезны, когда необходимо синхронизировать работу горутин. Буферизованные каналы позволяют увеличить эффективность взаимодействия горутин.
9. Канал закрывают через встроенную функцию `close`. Закрывать канал каждый раз нет необходимости. Это нужно лишь тогда, когда того требует логика программы. Например, чтобы читающая из канала горутина остановилась. 
10. Нужно помнить, что, на самом деле, при чтении из канала мы получаем два значения. Первым возвращается само значение, а потом — флаг. Этот флаг равен `true` в случае успешного чтения. Иначе — `false`. При чтении из закрытого канала вернется `false`.
11. Каналы — это ссылочный тип. Ссылка указывает на некоторую структуру. Если два канала указывают на одну структуру, то они равны. В противном случае — нет. Каналы допустимо сравнивать с `nil`.
12. Небуферизованный канал и канал с буфером на один элемент — это разные каналы. Небуферизованный канал используется для синхронизации горутин. Канал с буфером на один элемент позволяет горутине отправить значение в буфер и продолжать свою работу.
13. Канал с буфером на один элемент иногда используют в качестве мьютекса. Однако, если есть возможность работать с мьютексом, лучше применить мьютекс. Это явно подчеркивает намерение.
14. При работе с каналами используют ключевое слово `range`.
15. Каналы бывают однонаправленные и двунаправленные.
16. Конвейер — это прием, при котором выход одной горутины является входом для другой.
17. Сборщик мусора не останавливает «зависшие» горутины. Важно всегда самому заботиться о том, чтобы все горутины правильно завершились. 
