#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(unused_assignments)]

#INJECT-b585472fa

mod test {

    #[derive(Debug)]
    pub enum TestResult {
        WrongResult,
    }

    pub struct TestCase {
        left: f64,
        right: f64,
        epsilon: f64,
        expected: bool,
    }

    impl TestCase {
        pub fn new(left: f64, right: f64, epsilon: f64, expected: bool) -> TestCase {
            TestCase {
                left: left,
                right: right,
                epsilon: epsilon,
                expected: expected,
            }
        }
    }

    fn format_f64(value: f64) -> String {
        const E_FORMAT_EXP: u32 = 21;
        let exp = value.abs().log10().floor().abs() as u32;

        if exp < E_FORMAT_EXP || value == 0.0 {
            format!("{}", value)
        } else {
            format!("{:e}", value)
        }
    }

    pub fn test_approx_equal_abs(cases: &Vec<TestCase>) -> Result<(), TestResult> {
        for cur in cases {
            let result = super::approx_equal_abs(cur.left, cur.right, cur.epsilon);
            if result != cur.expected {
                println!(
                    "Ошибка! Входные параметры:\n\
                    - left:    {}\n\
                    - right:   {}\n\
                    - epsilon: {}\n\
                    Результат:\n\
                    - ожидаемый:  {}\n\
                    - полученный: {}",
                    format_f64(cur.left), format_f64(cur.right), format_f64(cur.epsilon), cur.expected, result
                );
                return Err(TestResult::WrongResult);
            }
        }
        Ok(())
    }
}   // mod test

fn main() -> Result<(), test::TestResult> {
    use test::*;

    let near_max = f64::from_bits(f64::MAX.to_bits() - 1);
    let near_min = f64::from_bits(f64::MIN.to_bits() - 1);

    let test_cases: Vec<TestCase> = vec![
        TestCase::new(10.0, 9.99999999999999822364, 0.1, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.01, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.0001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.00001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.000001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.0000001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.00000001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.000000001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.0000000001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.00000000001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.000000000001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.0000000000001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.00000000000001, true),
        TestCase::new(10.0, 9.99999999999999822364, 0.000000000000001, false),
        TestCase::new(10.0, 9.99999999999999822364, 0.0000000000000001, false),
        TestCase::new(0.0, 0.0, 0.0, true),
        TestCase::new(0.0, -0.0, 0.0, true),
        TestCase::new(-0.0, -0.0, 0.0, true),
        TestCase::new(1.0, 1.0, 0.0, true),
        TestCase::new(1.0, -1.0, 0.1, false),
        TestCase::new(-1.0, -1.0, 0.0, true),
        TestCase::new(1.0, 1.0 + f64::EPSILON, f64::EPSILON, true),
        TestCase::new(1.0, 1.0 + f64::EPSILON, 0.0, false),
        TestCase::new(1.0, 1.0 - f64::EPSILON, f64::EPSILON, true),
        TestCase::new(1.0, 1.0 - f64::EPSILON, 0.0, false),
        TestCase::new(-1.0, -1.0 - f64::EPSILON, f64::EPSILON, true),
        TestCase::new(-1.0, -1.0 - f64::EPSILON, 0.0, false),
        TestCase::new(-1.0, -1.0 + f64::EPSILON, f64::EPSILON, true),
        TestCase::new(-1.0, -1.0 + f64::EPSILON, 0.0, false),
        TestCase::new(f64::MIN, f64::MIN, 0.0, true),
        TestCase::new(f64::MIN, near_min, 2e292, true),
        TestCase::new(f64::MIN, near_min, 2e291, false),
        TestCase::new(f64::MAX, f64::MAX, 0.0, true),
        TestCase::new(f64::MAX, near_max, 2e292, true),
        TestCase::new(f64::MAX, near_max, 2e291, false),
        TestCase::new(f64::INFINITY, f64::INFINITY, 0.0, true),
        TestCase::new(f64::NEG_INFINITY, f64::NEG_INFINITY, 0.0, true),
    ];

    test_approx_equal_abs(&test_cases)
}
