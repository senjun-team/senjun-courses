
[comment]: # (TODO: При описаннии типов нужно рассказать также о функциональных типах и использование функций в переменных)

[comment]: # (TODO: В главе про дженерики следует использовать этот раздел про мономорфизацию)

Вложенные функции можно использовать в итераторах для преобразования последовательностей, но основное применение у них другое. Вложенные функции используются в обобщенных (generic) функциях для уменьшения размера исполняемого кода при мономорфизации.

**Мономорфизация** — это процесс во время компиляции, при котором каждая обобщенная функция заменяется множеством мономорфных функций для каждого случая использования обобщенной функции. Мономорфная функция — это функция, к каждому парметру которой может быть сопоставлен ровно один тип.

Например, в [fs::read_to_string()](https://github.com/rust-lang/rust/blob/master/library/std/src/fs.rs#L295-L304) из стандартной библиотеки используется внутренняя функция `inner()`, которая фактически выполняет всю работу, при этом в качестве параметра `inner()` выступает ссылка на структуру `Path` (конкретный тип):

```rust
pub fn read_to_string<P: AsRef<Path>>(path: P) -> io::Result<String> {
    fn inner(path: &Path) -> io::Result<String> {
        let mut file = File::open(path)?;
        let size = file.metadata().map(|m| m.len() as usize).ok();
        let mut string = String::with_capacity(size.unwrap_or(0));
        io::default_read_to_string(&mut file, &mut string, size)?;
        Ok(string)
    }
    inner(path.as_ref())
}
```

Во время компиляции для каждого фактического типа `P` будет создана своя версия `fs::read_to_string()`. Без внутренней функции каждый экземпляр `fs::read_to_string()` содержал бы полный код `inner()`. Благодаря наличию внутренней функции каждая версия `fs::read_to_string()` фактически будет содержать только вызов `inner()`. А `inner()` в скомпилиролванном коде будет существовать только в одном экземпляре. С помощью этого приема достигается уменьшение исполняемого кода проргаммы.


[comment]: # (TODO: Задачи на будущее)
1. Определить тип последовательности: возрастающая, убывающая или случайная.
2. Преобразовании строки в число (рефакторинг).
3. Перевод в строку ipv4 адрес, заданный в кортеже.
4. Тройной swap().
5. Битовое сжатие целых чисел или определение максимального количества байт необходимого для хранения чисел.
